# 内置数组

数组是复合结构，声明为`a[d]`，其中`a`为数组名，`d`为数组维度（常量表达式）。需要指定数组类型，且元素应该为对象，不存在引用的数组。

```c++
unsigned cnt = 42;
string bad[cnt];//错误
constexpr unsigned sz = 42;
string strs[sz];//正确
```

`const`和`constexpr`都可以来修饰对象和函数。



修饰对象的时候两者之间最基本的区别是：

- `const`修饰一个对象表示它是常量。这暗示对象一经初始化就不会再变动了，并且允许编译器使用这个特点优化程序。这也防止程序员修改了本不应该修改的对象。
- `constexpr`是修饰一个常量表达式。但请注意`constexpr`不是修饰常量表达式的唯一途径。

修饰函数的时候两者之间最基本的区别是：

- `const`只能用于非静态成员的函数而不是所有函数。它保证成员函数不修改任何非静态数据。
- `constexpr`可以用于含参和无参函数。`constexpr`函数适用于常量表达式，只有在下面的情况下编译器才会接受`constexpr`函数： 1.函数体必须足够简单，除了`typedef`和静态元素，只允许有`return`语句。如构造函数只能有初始化列表，`typedef`和静态元素 (实际上在C++14标准中已经允许定义语句存在于`constexpr`函数体内了) 2.参数和返回值必须是字面值类型





## 初始化/复制声明

进行列表初始化可忽略数组维度，给出数组维度当提供初始值数量小于维度则初始化靠前元素，剩下的初始化为默认值。其中字符数组可以用字符串字面值进行初始化，但是字符串字面值结尾还有应该空字符。

```c
char a1[]={'C','+','+'};//维度为3
char a2[]={'C','+','+','\0'};//维度为4
char a3[]="C++";//维度为4
const char a4[6]="Daniel"; //空间不足
```

```c++
int *p[10];//指针数组
int &q[10] = /?**/;//错误，不存在引用的数组
int (*p)[10] = &arr;//指向数组
int (&q)[10] = arr;//引用数组
```

## 操作

### 访问元素

使用下标或者`for`语句即可，下标一般定义为`size_t`类型，在`#include<stddef.h>`中定义，注意与`vector`下标定义是不同的。



### 数组和指针

使用数组的时候，在编译阶段编译器一般会把其转换成指针。



使用取地址符可以获取指向某个对象的指针，而数组的元素也是对象。

```c
string nums[]= {"one", "two", "three"};
string *p = &nums[0];
string *q = nums;
```





# 标准库类型



## 容器定义和初始化

容器都定义了一个默认构造函数。除了`array`以外的默认构造函数都会创建一个指定类型的空容器且接收容器大小和元素初始值的参数。

```c
C c;//默认初始化
C c1(c2);//直接初始化
C c1 = c2;//拷贝初始化
C c{a,b,c...};//以拷贝初始化的列表初始化
C c = {a,b,c...};//以直接初始化的列表初始化
C c(b,e);//需要进行创建临时对象的拷贝初始化
```

## String

标准库类型`string`表示可变长的字符串，使用该类型需要头文件`#include<string>`，且作为标准库的一部分定义在命名空间`std`。

### 初始化

作为标准库容器`string`，可以使用容器初始化的方式进行初始化。

```c
C c;//默认初始化
C c1(c2);//直接初始化
C c1 = c2;//拷贝初始化
C c{a,b,c...};//以拷贝初始化的列表初始化
C c = {a,b,c...};//以直接初始化的列表初始化
C c(b,e);//需要进行创建临时对象的拷贝初始化
```

```c++
string s1; //默认初始化
string s1(s2); //直接初始化
string s1 = s2; //拷贝初始化
string s1(5 , "Hello World");//需要进行创建临时对象的拷贝初始化，五个对象都为Hello World
```

除此以外，还可以使用字符串字面值进行直接/拷贝初始化。

```c
string s1 = "Hello World"; //C风格字符串（字符串字面值初始化）进行拷贝初始化，不推荐，一般是以空字符结束的字符数组进行初始化
string s1("Hello World");//C风格字符串（字符串字面值初始化）进行直接初始化，不推荐，一般是以空字符结束的字符数组进行初始化
```

其他构造`string`方法即`string`对象/字符数组来进行初始化。

```c
unsigned n,len2,pos2;
string s(cp, n); //cp为带空字符结束的字符数组
string s(s2, pos2, len2); //s表示string对象，从pos2位置开始拷贝，其中len2是可省参数
```

任何出现字符串字面值进行直接/拷贝初始化的都可以以空字符结束的字符数组（一般为`const char *c`的形式）作为参数初始化`string`（更一般情况下）。以`const char *c`构建`string`对象的时候，指针指向的数组必须以空字符结束。假如给予一个计数值，则不要求指针指向的数组必须以空字符结束。

```c
const char *c1 = "Hello World";//带空字符结束的数组
char c2[] = {'H','i','\0'};//带空字符结束的数组
char noNULL[] = {'H','i'};//不带空字符结束的数组

string s1(noNULL);//错误，不带空字符结束
string s2(c1);//正确，带空字符结束
string s3(c2);//正确，带空字符结束
string s4(c+6, 5);//正确。本质是指针，允许c+6
```

以`string`进行初始化的时候可以提供选择`pos`和`len2`（可省略）。

```c++
string s = "Hello World";
string s1(s);
string s2(s,6);//正确
string s3(s,6,5);//与string s4(c+6, 5)等价
string s4(s,6,20);//正确，最多复制到尾巴
```

可以使用拷贝，`substr`操作返回一个`string`，是`string`对象自己的全部或者部分拷贝。

```c++
s.substr(pos, n);//pos为下标，n为长度，如果n>s.size()，则复制到结尾
```

### 改变`string`的方法

`string`作为顺序容器，支持顺序容器的赋值表达式以及`assign`、`insert`、`erase`操作，

```c
seq.assign(b,e);
seq.assign(il);
seq.assign(n,t);
```



更定义了其独有的`insert`、`erase`操作。(未完成)



```c
s.insert(pos,args);//在pos前插入args指定的字符，pos可以是下标或者迭代器，下标返回指向s的引用，迭代器返回指向第一个插入字符的迭代器
s.erase(pos,len);//删除从位置pos开始的len个字符，len省略时候删除直到尾部所有字符
```

```c
s.insert(s.size(),5,'!');//在尾部加入五个感叹号
s.erase(s.size()-5, 5);//删除最后五个字符
```

也提供了支持C风格字符串（字符串字面值）的`assign`、`insert`操作。(未完成)

```c
const char *c = "Hello World";
s.assign(c. 6);
s.insert(s.size(), c + 6);
```

额外的成员函数：`append`和`replace`函数。其中`append`是`string`在末尾进行插入的简写。`replace`是`insert`、`erase`操作的简写（不要求删的字符长度和插入的字符长度一定相同）。

```c
s.insert(s.size(), "Hello World");
s.append("Hello World");
```

```c
s.erase(11,3);
s.insert(11,"Hello World");
s.replace(11,3,"Hello World")
```



### 操作

#### 读取字符串

一、`	IO`操作符



`string`对象自动忽略开头的空白（空格符、换行符、制表符）从第一个字符开始读取。

```c++
#include<iostream>
int main(){
    string s;
    cin>>s;
    return 0;
}
```

读取未知数量的`string`对象。

```c
#include<iostream>
int main(){
    string s;
    while(cin>>s){
    	cin>>s; 
    }
    return 0;
}
```

二、`getline`函数



在`#include<string>`的`getline`函数：从给定输入流中读取内容直到遇到换行符，把内容存入`string`对象（读换行符但是不存入）。

```c
#include<string>
int main(){
    string s;
    while(getline(cin, s)){
    	cin>>s; 
    }
    return 0;
}
```

#### 判空和长度

一、`s.empty()`



判断字符串是否为空，返回布尔值。



二、`s.size()`



返回`string`对象长度。



`size`函数返回一个`string::size_type`，这是该标准库`string`所定义的关于`string`的配套类型，其是一个无符号类型值且能放下任何`string`对象的大小，一般情况下使用`auto`或者`decltyoe`作返回值类型允许编译器自己判断变量类型。

```c++
decltype(s.size()) length = s.size();
auto length = s.size();
```

#### 字符串对象的比较

直接使用相等性运算符和关系运算发进行比较即可。

#### 字符串对象的相加

1、`string`对象加`string`对象。

```c
s3 = s1 + s2;
s1 += s2;
```

2、`string`对象加字符字面值/字符串字面值。

```c
s1 +=  ",";
s2 +=  "Hi";//不推荐，一般是以空字符结束的字符数组替代字符串字面值进行初始化
```

注意：

1. `+`的两边必须有一个`string`对象。
2. 字符串字面值（C风格字符串）不是`string`对象。

#### 处理字符串

掌握`#include<cctype>`下的一些函数可以很快处理单个字符。

```c
#include<cctype>
isalnum(c);
isalpha(c);
iscntrl(c);
isdigit(c);
isgraph(c);
islower(c);
issupper(c);
isprint(c);
ispunct(c);
isxdigit(c);
tolower(c);
toupper(c);
```

一、处理每一个字符



使用`for`函数可以快速遍历整个`string`对象，需要修改的时候使用`auto &`。

```c
for(declaration : expression){
    statement;
}
```

二、处理单个字符



使用下标或者迭代器来进行随机访问`string`对象的某个字符。

```c
for(decltype(s.size()) index = 0; index !=s.size() && !isspace(s[index]); ++index){
    s[index] = toupper(s[index]); //把string对象的第一个词转为大写
}
```

```c
const string hexdigits = "012345678ABCDEF";
string result;
string::size_type n;
while(cin>>n){
    if(n < hexdigits.size()){
        result += hexdigit[n]l//进制转换
    }
}
```

## 搜索操作

`string`提供6个搜索函数，每个函数4个重载版本。搜索成功返回`string::size_type`值表示匹配下标，失败返回`string::npos`的一个静态成员。建议以`string::size_type`/`auto`（常用）类型变量进行保存。

```c
s.find(arg);
s.rfind(arg);
s.find_first_of(arg);
s.find_last_of(arg);
s.find_first_not_of(arg);
s.find_last_not_of(arg);
```

```c
arg是下列形式:
c,pos //字符
s2,pos //string对象
cp,pos //字符串字面值
cp,pos,n //指针cp指向数组
```

其中`pos`是`s`的位置，前三个默认值为0，但在最后一个重载中`pos`和`n`是没有默认值的，需要显示给予。在`pos`默认为0的情况下，可以多次在字符串中循环搜索子字符串出现的所有位置。

```c++
string::size_type pos = 0;
while(!(pos = name.find_first_of(numbers, pos)!=string::npos)){
    
}
```





## 数值转换

新标准引入多个函数进行数值数据和`string`的转换。

```c++
to_string(val);//返回数值val的String表示
stoi
```



## vector

标准库类型`vector`表示对象的集合，其中所有的对象类型都相同，本质上是一个类模板。每个对象都有对应的索引。使用该类型需要`#include<vector>`，且作为标准库的一部分定义在命名空间`std`。由于引用不是对象，因此不存在包含引用的`vector`。

### 初始化

主要分为默认初始化、拷贝初始化、直接初始化、列表初始化四种方式。

```c
vector<T> v1; //默认初始化
vector<T> v2(v1); //拷贝初始化
vector<T> v3 = v1; //直接初始化
vector<T> v4(int n, val);//n个元素，值全为val
vector<T> v5(int n);//n个元素，值实行默认初始化
vector<T> v6{a,b,c,d,....}; //列表初始化
vector<T> v7 = {a,b,c,d,....} //列表初始化的直接初始化
```

假如`T`是`int`则默认初始化为0，假如`T`是`String`则默认初始化为NULL，

```c++
vector<int> v1(10);//构造vector对象
vector<int> v2{10};//列表初始化
vector<int> v3(10, 1);//构造vector对象
vector<int> v4{10, 1};//列表初始化
vector<string> v5{10};//列表初始化但类型不同，转为构造vector对象
vector<string>	v6{10,"hi"};//列表初始化但类型不同，转为构造vector对象
```

### 操作

#### 插入新元素

```c
#include<vector>
#include<iostream>
int main(){
  vector<int> v1;
  int i;
  cin>>i;
  v1.push_back(i);
}
```

`vector`不允许用下标方式添加元素，只能以下标访问已有元素。

#### 判空和长度

```c
v1.empty();
v1.size();
```

`size`函数返回一个`vector<T>::size_type`，这是该标准库`vector<T>`所定义的关于`vector<T>`的配套类型，其是一个无符号类型值且能放下任何`vector<T>`对象的大小，一般情况下使用`auto`或者`decltyoe`作返回值类型允许编译器自己判断变量类型。

```c++
decltype(vector<T>) length = s.size();
auto length = s.size();
```

#### 类型的比较

直接使用相等性运算符和关系运算发进行比较即可。需要对象类型是可比较的，才能进行`vector<T>`的比较。

## 迭代器的使用

只有少部分容器可以使用下标运算符，而所有标准库容器都可以使用迭代器。迭代器提供了对对象的间接访问，对迭代器来说，对象是容器元素或者是`string`的字符。迭代器可以访问、移动元素。

```c++
auto b = v.begin();
auto c = v.end();
```

一个指向首元素，一个指向尾元素的下一个，当容器为空时，返回同一个迭代器。

```c++
*iter //引用
iter->mem //等价（*iter）.mem,解引用，访问某类对应对象的成员
++/-- iter
iter1 ==/!= iter2
iter +/- n
iter +=/-= n
iter1 - iter2
```

迭代器类型，一般使用`auto`让编译器自己判断即可。

```c++
vector<int>::iterator it1;
vector<int>::const_iterator it2;//对应 const vector<int>，只读
string::iterator it3;
string::const_iterator it4;//对应 const string，只读
```

假如容器只需读的话使用`cbegin`函数和`cend`函数，返回`const_iterator`

```c
auto it = v.cbegin();
auto it = v.cend(); 
```

注意，使用了迭代器的循环体都不要向迭代器所属容器中添加数据。



# 