# C/C++基础

## C++内存

### 简述一下堆和栈的区别

1. **堆栈空间分配不同**。栈由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等；堆一般由程序员分配释放。
2. **堆栈缓存方式不同**。栈使用的是一级缓存， 它们通常都是被调用时处于存储空间中，调用完毕立即释放；堆则是存放在二级缓存中，速度要慢些。
3. **堆栈数据结构不同**。堆类似数组结构；栈类似栈结构，先进后出。

### 简述C++的内存管理

#### 内存分配方式

在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。

1. **栈**，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。

2. **堆**，就是那些由new分配的内存块，一般一个new就要对应一个delete。

3. **自由存储区**，就是那些由malloc等分配的内存块，和堆是十分相似的，不过是用free来结束自己的生命。

4. **全局/静态存储区**，全局变量和静态变量被分配到同一块内存中

5. **常量存储区**，这是一块比较特殊的存储区，里面存放的是常量，不允许修改。

#### 常见的内存错误及应对

以下为内存一些常见的内存错误：

- 内存分配未成功，却使用了它

- 内存分配虽然成功，但是尚未初始化就引用它

- 内存分配成功并且已经初始化，但操作越过了内存的边界

- 忘记了释放内存，造成内存泄露

- 释放了内存却继续使用它

接下来介绍如何避免这些问题（使用指针需要注意什么）：

- 定义指针时，先初始化为`NULL`/`0`/`nullptr`。

- 用malloc或new申请内存之后，应该**立即检查**指针值是否为NULL。防止使用指针值为NULL的内存。

- 不要忘记为数组和动态内存**赋初值**。防止将未被初始化的内存作为右值使用。

- 避免数字或指针的下标**越界**，特别要当心发生“多1”或者“少1”操作

- 动态内存的申请与释放必须配对，防止**内存泄漏**

- 用free或delete释放了内存之后，立即将指针**设置为NULL**，防止“野指针”

- 使用智能指针

#### 内存泄露

简单地说就是申请了一块内存空间，使用完毕后没有释放掉。（1）new和malloc申请资源使用后，没有用delete和free释放；（2）子类继承父类时，父类析构函数不是虚函数。（3）Windows句柄资源使用后没有释放。

#### 如何避免内存错误

第一：良好的编码习惯，使用了内存分配的函数，一旦使用完毕,要记得使用其相应的函数释放掉。

第二：将分配的内存的指针以链表的形式自行管理，使用完毕之后从链表中删除，程序结束时可检查改链表。

第三：使用智能指针。

### 程序有哪些section，分别的作用？程序启动的过程？



![img](https://uploadfiles.nowcoder.com/images/20220225/4107856_1645788015668/798C7A2D023204559B62F88B54E35CBB)



如上图，**从低地址到高地址，一个程序由代码段、数据段、BSS段、堆、共享区、栈等**组成。

1. **数据段：**存放程序中已初始化的全局变量和静态变量的一块内存区域。

2. **代码段：**存放程序执行代码的一块内存区域。只读，代码段的头部还会包含一些只读的常数变量。

3. **BSS** 段：存放程序中未初始化的全局变量和静态变量的一块内存区域。

4. 可执行程序在运行时又会多出两个区域：堆区和栈区。

   **堆区：**动态申请内存用。堆从低地址向高地址增长。

   **栈区：**存储局部变量、函数参数值。栈从高地址向低地址增长。是一块连续的空间。

5. 最后还有一个**共享区**，位于堆和栈之间。

**程序启动的过程：**

1. 操作系统首先创建相应的进程并分配私有的进程空间，然后操作系统的加载器负责把可执行文件的数据段和代码段映射到进程的虚拟内存空间中。
2. 加载器读入可执行程序的导入符号表，根据这些符号表可以查找出该可执行程序的所有依赖的动态链接库。
3. 加载器针对该程序的每一个动态链接库调用`LoadLibrary` （1）查找对应的动态库文件，加载器为该动态链接库确定一个合适的基地址。 （2）加载器读取该动态链接库的导入符号表和导出符号表，比较应用程序要求的导入符号是否匹配该库的导出符号。 （3）针对该库的导入符号表，查找对应的依赖的动态链接库，如有跳转，则跳到3 （4）调用该动态链接库的初始化函数
4. 初始化应用程序的全局变量，对于全局对象自动调用构造函数。
5. 进入应用程序入口点函数开始执行。

**怎么判断数据分配在栈上还是堆上：**首先局部变量分配在栈上；而通过malloc和new申请的空间是在堆上。

### 初始化为0的全局变量在`bss`还是`data`

BSS段通常是指用来存放程序中未初始化的或者初始化为0的全局变量和静态变量的一块内存区域。特点是可读写的，在程序执行之前BSS段会自动清0。

### 简述C++中内存对齐的使用场景

内存对齐应用于三种数据类型中：**struct/class/union**



struct/class/union内存对齐原则有四个：

1. 数据成员对齐规则：结构(`struct`)或联合(`union`)的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小的整数倍开始。
2. 结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部"最宽基本类型成员"的整数倍地址开始存储。(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储)。
3. 收尾工作:结构体的总大小，也就是`sizeof`的结果，必须是其内部最大成员的"最宽基本类型成员"的整数倍。不足的要补齐。(基本类型不包括`struct`/`class`/`uinon`)。
4. `sizeof(union)`，以结构里面size最大元素为union的size，因为在某一时刻，union只有一个成员真正存储于该地址。

**答案解析**

1. **什么是内存对齐？**

   那么什么是字节对齐？在C语言中，结构体是一种复合数据类型，其构成元素既可以是基本数据类型（如int、long、float等）的变量，也可以是一些复合数据类型（如数组、结构体、联合体等）的数据单元。在结构体中，**编译器为结构体的每个成员按其自然边界（alignment）分配空间。**各个成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构体的地址相同。

   为了使CPU能够对变量进行快速的访问，变量的起始地址应该具有某些特性，**即所谓的“对齐”，比如4字节的int型，其起始地址应该位于4字节的边界上，即起始地址能够被4整除**，也即“对齐”跟数据在内存中的位置有关。如果一个变量的内存地址正好位于它长度的整数倍，他就被称做自然对齐。

   比如在32位cpu下，假设一个整型变量的地址为0x00000004(为4的倍数)，那它就是自然对齐的，而如果其地址为0x00000002（非4的倍数）则是非对齐的。现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。

2. **为什么要字节对齐？**

   需要字节对齐的根本原因在于CPU访问数据的效率问题。假设上面整型变量的地址不是自然对齐，比如为0x00000002，则CPU如果取它的值的话需要访问两次内存，第一次取从0x00000002-0x00000003的一个short，第二次取从0x00000004-0x00000005的一个short然后组合得到所要的数据，如果变量在0x00000003地址上的话则要访问三次内存，第一次为char，第二次为short，第三次为char，然后组合得到整型数据。

   而如果变量在自然对齐位置上，则只要一次就可以取出数据。一些系统对对齐要求非常严格，比如sparc系统，如果取未对齐的数据会发生错误，而在x86上就不会出现错误，只是效率下降。

   各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。显然在读取效率上下降很多。

3. **字节对齐实例**

   ```C++
   union example {   
       int a[5];   //20
       char b;   
       double c;   
   };   
   int result = sizeof(example);   
   /* 如果以最长20字节为准，内部double占8字节，这段内存的地址0x00000020并不是double的整数倍，只有当最小为0x00000024时可以满足整除double（8Byte）同时又可以容纳int a[5]的大小，所以正确的结果应该是result=24 */ 
   struct example {   
       int a[5];   
       char b;  
       double c;  
   }test_struct; 
   int result = sizeof(test_struct);   /* 如果我们不考虑字节对齐，那么内存地址0x0021不是double（8Byte）的整数倍，所以需要字节对齐，那么此时满足是double（8Byte）的整数倍的最小整数是0x0024，说明此时char b对齐int扩充了三个字节。所以最后的结果是result=32 */  struct example {
       char b;  
       double c;  
       int a;  
   }test_struct; 
   int result = sizeof(test_struct);   /* 字节对齐除了内存起始地址要是数据类型的整数倍以外，还要满足一个条件，那就是占用的内存空间大小需要是结构体中占用最大内存空间的类型的整数倍，所以20不是double（8Byte）的整数倍，我们还要扩充四个字节，最后的结果是result=24 */
   ```

## 面向对象

### 简述一下什么是面向对象

1. 面向对象是一种编程思想，把一切东西看成是一个个对象，比如人、耳机、鼠标、水杯等，他们各自都有属性，比如：耳机是白色的，鼠标是黑色的，水杯是圆柱形的等等，把这些对象拥有的属性变量和操作这些属性变量的函数打包成一个类来表示。

2. 面向过程和面向对象的区别

   面向过程：根据业务逻辑从上到下写代码。

   面向对象：将数据与函数绑定到一起，进行封装，这样能够更快速的开发程序，减少了重复代码的重写过程。

### 简述一下面向对象的三大特征

面向对象的三大特征是封装、继承、多态。

1. 封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互，封装本质上是一种管理。

2. 继承：可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。

   三种继承方式

   | 继承方式            | private继承     | protected继承     | public继承                   |
   | ------------------- | --------------- | ----------------- | ---------------------------- |
   | 基类的private成员   | 不可见          | 不可见            | 不可见                       |
   | 基类的protected成员 | 变为private成员 | 仍为protected成员 | 仍为protected成员            |
   | 基类的public成员    | 变为private成员 | 变为protected成员 | 仍为public成员仍为public成员 |

3. 多态：用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。实现多态，有二种方式，重写，重载。

### 简述一下 C++ 的重载和重写，以及它们的区别/原理

重写，是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类对象调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。

```c++
#include<bits/stdc++.h>  
using namespace std;  

class A { 
    public:  
    	virtual void fun()  {   cout << "A";  } 
};
class B :public A {
    public:  
    	virtual void fun()  {   cout << "B";  } 
};
int main(void) { 
    A* a = new B();  
    a->fun();//输出B，A类中的fun在B类中重写 
}
```

在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。

1. 用virtual关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数。
2. 存在虚函数的类都有一个一维的虚函数表叫做虚表，类的对象有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的。
3. 多态性是一个接口多种实现，是面向对象的核心，分为类的多态性和函数的多态性。
4. 重写用虚函数来实现，结合动态绑定。
5. 纯虚函数是虚函数再加上 = 0。
6. 抽象类是指包括至少一个纯虚函数的类。

纯虚函数：virtual void fun()=0。即抽象类必须在子类实现这个函数，即先有名称，没有内容，在派生类实现内容。



重载，我们在平时写代码中会用到几个函数但是他们的实现功能相同，但是有些细节却不同。例如：交换两个数的值其中包括（int, float,char,double)这些个类型。在C语言中我们是利用不同的函数名来加以区分。这样的代码不美观而且给程序猿也带来了很多的不便。



于是在C++中人们提出了用一个函数名定义多个函数，也就是所谓的函数重载。函数重载是指同一可访问区内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。

```c++
#include<bits/stdc++.h>  
using namespace std;  
class A {  
    void fun() {};  
    void fun(int i) {};  
    void fun(int i, int j) {};     
    void fun1(int i,int j){}; 
};
```

C++利用命名倾轧（name mangling）技术，来改名函数名，区分参数不同的同名函数实现重载。命名倾轧是在编译阶段完成的。

```c++
#include<iostream> 
using namespace std; 
int func(int a,double b) {  
    return ((a)+(b)); 
} 
int func(double a,float b) {  
    return ((a)+(b)); 
} 
int func(float a,int b) {
    return ((a)+(b)); 
} 
int main() {  return 0; }
```

![img](https://uploadfiles.nowcoder.com/images/20220225/4107856_1645788124958/5E57B0F4AE72F40057C2EAA16C4DB902)



由上图可得，d代表double，f代表float，i代表int，加上参数首字母以区分同名函数。

### 说说 C 语言如何实现 C++ 语言中的重载

c语言中不允许有同名函数，因为编译时函数命名是一样的，不像c++会添加参数类型和返回类型作为函数编译后的名称，进而实现重载。如果要用c语言显现函数重载，可通过以下方式来实现：

1. 使用函数指针来实现，重载的函数不能使用同名称，只是类似的实现了函数重载功能
2. 重载函数使用可变参数，方式如打开文件`open`函数
3. `gcc`有内置函数，程序使用编译函数可以实现函数重载

```c++
#include<stdio.h>   
void func_int(void * a) {     
    printf("%d\n",*(int*)a);  //输出int类型，注意 void * 转化为int 
}   
void func_double(void * b) {     
    printf("%.2f\n",*(double*)b); 
}   
typedef void (*ptr)(void *);  //typedef申明一个函数指针   
void c_func(ptr p,void *param) {     
    p(param);                //调用对应函数
}   
int main() {    
    int a = 23;  
    double b = 23.23;  
    c_func(func_int,&a);   
    c_func(func_double,&b); 
    return 0; 
}
```

### 说说构造函数有几种，分别什么作用

C++中的构造函数可以分为4类：默认构造函数、初始化构造函数、拷贝构造函数、移动构造函数。



1. 默认构造函数和初始化构造函数。 在定义类的对象的时候，完成对象的初始化工作。

   ```C++
   class Student { 
       public:  //默认构造函数  
           Student()  {    
               num=1001;       
               age=18;      
           }  //初始化构造函数  
           Student(int n,int a):num(n),age(a){} 
       private:  
           int num;  
           int age; 
   }; 
   int main() {  //用默认构造函数初始化对象S1 
       Student s1;  //用初始化构造函数初始化对象S2 
       Student s2(1002,18);  
       return 0; }
   ```

   有了有参的构造了，编译器就不提供默认的构造函数。

2. 拷贝构造函数

   ```C++
   #include "stdafx.h" 
   #include "iostream.h"  
   class Test {   
       int i;    
       int *p; public:  
       Test(int ai,int value)   {       
           i = ai;    
           p = new int(value);  
       }     
       ~Test()     {  
           delete p;  
       }     
       Test(const Test& t)   {     
           this->i = t.i;       
           this->p = new int(*t.p);   
       } }; //复制构造函数用于复制本类的对象 
   int main(int argc, char* argv[]) {    
       Test t1(1,2);    
       Test t2(t1);//将对象t1复制给t2。注意复制和赋值的概念不同    
       return 0; 
   }
   ```

   赋值构造函数默认实现的是值拷贝（浅拷贝）。

3. 移动构造函数。用于将其他类型的变量，隐式转换为本类对象。下面的转换构造函数，将int类型的r转换为Student类型的对象，对象的age为r，num为1004.

   ```C++
   Student(int r) { 
       int num=1004; 
       int age= r; 
   }
   ```

### 只定义析构函数，会自动生成哪些构造函数？

只定义了析构函数，编译器将自动为我们生成拷贝构造函数和默认构造函数。 在定义类的对象的时候，完成对象的初始化工作。

```c++
class Student { 
    public:  //默认构造函数 
        Student()  {  
            num=1001;      
            age=18;     
        }  //初始化构造函数  
        Student(int n,int a):num(n),age(a){} 
    private: 
        int num; 
        int age; 
}; 
int main() {  //用默认构造函数初始化对象S1  
    Student s1;  //用初始化构造函数初始化对象S2  
    Student s2(1002,18); 
    return 0; }
```

有了有参的构造了，编译器就不提供默认的构造函数。



拷贝构造函数

```C++
#include "stdafx.h"
#include "iostream.h"

class Test
{
    int i;
    int *p;
public:
    Test(int ai,int value)
    {
        i = ai;
        p = new int(value);
    }
    ~Test()
    {
        delete p;
    }
    Test(const Test& t)
    {
        this->i = t.i;
        this->p = new int(*t.p);
    }
};

int main(int argc, char* argv[])
{
    Test t1(1,2);
    Test t2(t1);//将对象t1复制给t2。注意复制和赋值的概念不同。
    
    return 0;
}
```

赋值构造函数默认实现的是值拷贝（浅拷贝）。

### 说说一个类，默认会生成哪些函数

定义一个空类

```C++
class Empty
{
};
```

默认会生成以下几个函数

1. 无参的构造函数

   在定义类的对象的时候，完成对象的初始化工作。

```C++
Empty()
{
}
```

2. 拷贝构造函数

拷贝构造函数用于复制本类的对象

```C++
Empty(const Empty& copy)
{
}
```

3. 赋值运算符

```C++
Empty& operator = (const Empty& copy)
{
}
```

4. 析构函数（非虚）

```C++
~Empty()
{
}
```

### 说说 C++ 类对象的初始化顺序，有多重继承情况下的顺序

**参考答案**

1. 创建派生类的对象，基类的构造函数优先被调用（也优先于派生类里的成员类）；

2. 如果类里面有成员类，成员类的构造函数优先被调用；(也优先于该类本身的构造函数）

3. 基类构造函数如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序而不是它们在成员初始化表中的顺序；

4. 成员类对象构造函数如果有多个成员类对象，则构造函数的调用顺序是对象在类中被声明的顺序而不是它们出现在成员初始化表中的顺序；

5. 派生类构造函数，作为一般规则派生类构造函数应该不能直接向一个基类数据成员赋值而是把值传递给适当的基类构造函数,否则两个类的实现变成紧耦合的（tightly coupled）将更加难于正确地修改或扩展基类的实现。（基类设计者的责任是提供一组适当的基类构造函数）

6. 综上可以得出，初始化顺序：

   父类构造函数–>成员类对象构造函数–>自身构造函数

   其中成员变量的初始化与声明顺序有关，构造函数的调用顺序是类派生列表中的顺序。

   析构顺序和构造顺序相反。

### 简述下向上转型和向下转型

1. 子类转换为父类：向上转型，使用dynamic`[daɪ'næmɪk]`_cast<type_id>(expression)，这种转换相对来说比较安全不会有数据的丢失；
2. 父类转换为子类：向下转型，可以使用强制转换，这种转换时不安全的，会导致数据的丢失，原因是父类的指针或者引用的内存中可能不包含子类的成员的内存。

###  简述下深拷贝和浅拷贝，如何实现深拷贝

1. 浅拷贝：又称值拷贝，将源对象的值拷贝到目标对象中去，本质上来说源对象和目标对象共用一份实体，只是所引用的变量名不同，地址其实还是相同的。举个简单的例子，你的小名叫西西，大名叫冬冬，当别人叫你西西或者冬冬的时候你都会答应，这两个名字虽然不相同，但是都指的是你。

2. 深拷贝，拷贝的时候先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标对象中去，这样两个指针就指向了不同的内存位置。并且里面的内容是一样的，这样不但达到了我们想要的目的，还不会出现问题，两个指针先后去调用析构函数，分别释放自己所指向的位置。即为每次增加一个指针，便申请一块新的内存，并让这个指针指向新的内存，深拷贝情况下，不会出现重复释放同一块内存的错误。

3. 深拷贝的实现：深拷贝的拷贝构造函数和赋值运算符的重载传统实现：

   ```C++
   STRING( const STRING& s )
   {
       //_str = s._str;
       _str = new char[strlen(s._str) + 1];
       strcpy_s( _str, strlen(s._str) + 1, s._str );
   }
   STRING& operator=(const STRING& s)
   {
       if (this != &s)
       {
           //this->_str = s._str;
           delete[] _str;
           this->_str = new char[strlen(s._str) + 1];
           strcpy_s(this->_str, strlen(s._str) + 1, s._str);
       }
       return *this;
   }
   ```

   这里的拷贝构造函数我们很容易理解，先开辟出和源对象一样大的内存区域，然后将需要拷贝的数据复制到目标拷贝对象 ， 那么这里的赋值运算符的重载是怎么样做的呢？

![img](https://uploadfiles.nowcoder.com/images/20220225/4107856_1645788163127/9F844C99D8A154A32CA23995A7C1661B)

### 简述一下 C++ 中的多态

由于派生类重写基类方法，然后用基类引用/指针指向派生类对象，调用方法时候会进行动态绑定，这就是多态。 多态分为静态多态和动态多态：

1. 静态多态：编译器在编译期间完成的，编译器会根据实参类型来推断该调用哪个函数，如果有对应的函数，就调用，没有则在编译时报错。比如一个简单的加法函数：

   ```C++
include<iostream>
   using namespace std;
   
   int Add(int a,int b)//1
   {
       return a+b;
   }
   
   char Add(char a,char b)//2
   {
       return a+b;
   }
   
   int main()
   {
       cout<<Add(666,888)<<endl;//1
       cout<<Add('1','2');//2
       return 0;
   }
   ```
   
   显然，第一条语句会调用函数1，而第二条语句会调用函数2，这绝不是因为函数的声明顺序，不信你可以将顺序调过来试试。

2. 动态多态：其实要实现动态多态，需要几个条件——即动态绑定条件：

   1. 虚函数。基类中必须有虚函数，在派生类中必须重写虚函数。
   2. 通过基类类型的指针或引用来调用虚函数。

   说到这，得插播一条概念：重写——也就是基类中有一个虚函数，而在派生类中也要重写一个原型（返回值、名字、参数）都相同的虚函数。不过协变例外。协变是重写的特例，基类中返回值是基类类型的引用或指针，在派生类中，返回值为派生类类型的引用或指针。

   ```C++
   //协变测试函数
   #include<iostream>
   using namespace std;
   
   class Base
   {
   public:
       virtual Base* FunTest()
       {
           cout << "victory" << endl;
           return this;
       }
   };
   
   class Derived :public Base
   {
   public:
       virtual Derived* FunTest()
       {
           cout << "yeah" << endl;
           return this;
       }
   };
   
   int main()
   {
       Base b;
       Derived d;
   
       b.FunTest();
       d.FunTest();
   
       return 0;
   }
   ```



### 说说为什么要虚析构

虚析构：将可能会被继承的基类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。如果基类的析构函数不是虚函数，在特定情况下会导致派生来无法被析构。

1. 用派生类类型指针绑定派生类实例，析构的时候，不管基类析构函数是不是虚函数，都会正常析构
2. 用基类类型指针绑定派生类实例，析构的时候，如果基类析构函数不是虚函数，则只会析构基类，不会析构派生类对象，从而造成内存泄漏。为什么会出现这种现象呢，个人认为析构的时候如果没有虚函数的动态绑定功能，就只根据指针的类型来进行的，而不是根据指针绑定的对象来进行，所以只是调用了基类的析构函数；如果基类的析构函数是虚函数，则析构的时候就要根据指针绑定的对象来调用对应的析构函数了。

C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。

### 说说类继承时，派生类对不同关键字修饰的基类方法的访问权限

类中的成员可以分为三种类型，分别为public成员、protected成员、public成员。类中可以直接访问自己类的public、protected、private成员，但类对象只能访问自己类的public成员。

1. public继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员； 派生类对象可以访问基类的public成员，不可以访问基类的protected、private成员。
2. protected继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员； 派生类对象不可以访问基类的public、protected、private成员。
3. private继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员； 派生类对象不可以访问基类的public、protected、private成员。

### 简述一下移动构造函数，什么库用到了这个函数？777

C++11中新增了移动构造函数。与拷贝类似，移动也使用一个对象的值设置另一个对象的值。但是，又与拷贝不同的是，移动实现的是对象值真实的转移（源对象到目的对象）：源对象将丢失其内容，其内容将被目的对象占有。



移动操作的发生的时候，是当移动值的对象是未命名的对象的时候。这里未命名的对象就是那些临时变量，甚至都不会有名称。典型的未命名对象就是函数的返回值或者类型转换的对象。使用临时对象的值初始化另一个对象值，不会要求对对象的复制：因为临时对象不会有其它使用，因而，它的值可以被移动到目的对象。做到这些，就要使用移动构造函数和移动赋值：当使用一个临时变量对对象进行构造初始化的时候，调用移动构造函数。类似的，使用未命名的变量的值赋给一个对象时，调用移动赋值操作。



移动操作的概念对对象管理它们使用的存储空间很有用的，诸如对象使用new和delete分配内存的时候。在这类对象中，拷贝和移动是不同的操作：从A拷贝到B意味着，B分配了新内存，A的整个内容被拷贝到为B分配的新内存上。 而从A移动到B意味着分配给A的内存转移给了B，没有分配新的内存，它仅仅包含简单地拷贝指针。 看下面的例子：

```C++
// 移动构造函数和赋值
#include <iostream>
#include <string>
using namespace std;

class Example6 {
    string* ptr;
public:
    Example6 (const string& str) : ptr(new string(str)) {}
    ~Example6 () {delete ptr;}
    // 移动构造函数，参数x不能是const Pointer&& x，
    // 因为要改变x的成员数据的值；
    // C++98不支持，C++0x（C++11）支持
    Example6 (Example6&& x) : ptr(x.ptr) 
    {
        x.ptr = nullptr;
    }
    // move assignment
    Example6& operator= (Example6&& x) 
    {
        delete ptr; 
        ptr = x.ptr;
        x.ptr=nullptr;
        return *this;
    }
    // access content:
    const string& content() const {return *ptr;}
    // addition:
    Example6 operator+(const Example6& rhs) 
    {
        return Example6(content()+rhs.content());
    }
};
int main () {
    Example6 foo("Exam");           // 构造函数
    // Example6 bar = Example6("ple"); // 拷贝构造函数
    Example6 bar(move(foo));     // 移动构造函数
                                // 调用move之后，foo变为一个右值引用变量，
                                // 此时，foo所指向的字符串已经被"掏空"，
                                // 所以此时不能再调用foo
    bar = bar+ bar;             // 移动赋值，在这儿"="号右边的加法操作，
                                // 产生一个临时值，即一个右值
                                 // 所以此时调用移动赋值语句
    cout << "foo's content: " << foo.content() << '\n';
    return 0;
}
```

执行结果：

```C++
foo's content: Example
```

### 请你回答一下 C++ 类内可以定义引用数据成员吗？777

c++类内可以定义引用成员变量，但要遵循以下三个规则：

1. 不能用默认构造函数初始化，必须提供构造函数来初始化引用成员变量。否则会造成引用未初始化错误。
2. 构造函数的形参也必须是引用类型。
3. 不能在构造函数里初始化，必须在初始化列表中进行初始化。

### 构造函数为什么不能被声明为虚函数？

1. 从虚函数的调用角度：使用虚函数是在对象进行初始化的时候，把其虚表指针指向当前类的虚表，而构造函数本身是用以实例化对象，因此本身这种说法是谬论。
2. 从虚函数的使用角度：虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。且虚函数的多态性是以父类的指针或者引用去调用，构造函数必定是以实例化对象的时候自动调用，因此也就规定构造函数不能是虚函数。

### 简述一下什么是常函数，有什么作用

类的成员函数后面加 const，表明这个函数不会对这个类对象的数据成员（准确地说是非静态数据成员）作任何改变。在设计类的时候，一个原则就是对于不改变数据成员的成员函数都要在后面加const，而对于改变数据成员的成员函数不能加 const。



所以 const 关键字对成员函数的行为作了更明确的限定：有 const 修饰的成员函数（指 const 放在函数参数表的后面，而不是在函数前面或者参数表内），只能读取数据成员，不能改变数据成员；没有 const 修饰的成员函数，对数据成员则是可读可写的。



除此之外，在类的成员函数后面加 const 时，常量（即 const）对象可以调用 const 成员函数，而不能调用非const修饰的成员函数。正如非const类型的数据可以给const类型的变量赋值一样，反之则不成立。

```C++
#include<iostream>
using namespace std;
 
class CStu
{
public:
    int a;
    CStu()
    {
        a = 12;
    }
 
    void Show() const
    {
        //a = 13; //常函数不能修改数据成员
        cout <<a << "I am show()" << endl;
    }
};
 
int main()
{
    CStu st;
    st.Show();
    system("pause");
    return 0;
}
```

### **简述一下虚函数和纯虚函数，以及实现原理**

C++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型的指针/引用指向其子类的实例，然后通过父类的指针/引用调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。



如果调用非虚函数，则无论实际对象是什么类型，都执行基类类型所定义的函数。非虚函数总是在编译时根据调用该函数的对象，引用或指针的类型而确定。如果调用虚函数，则直到运行时才能确定调用哪个函数，运行的虚函数是引用所绑定或指针所指向的对象所属类型定义的版本。



虚函数必须是基类的非静态成员函数。虚函数的作用是实现动态联编，也就是在程序的运行阶段动态地选择合适的成员函数，在定义了虚函数后，可以在基类的派生类中对虚函数重新定义，在派生类中重新定义的函数应与虚函数具有相同的形参个数和形参类型。以实现统一的接口，不同定义过程。如果在派生类中没有对虚函数重新定义，则它继承其基类的虚函数。

```C++
class Person{
    public:
        //虚函数
        virtual void GetName(){
            cout<<"PersonName:xiaosi"<<endl;
        };
};
class Student:public Person{
    public:
        void GetName(){
            cout<<"StudentName:xiaosi"<<endl;
        };
};
int main(){
    //指针
    Person *person = new Student();
    //基类调用子类的函数
    person->GetName();//StudentName:xiaosi
}
```

虚函数（`Virtual Function`）是通过一张虚函数表（`Virtual Table`）来实现的。简称为`V-Table`。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。



纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0” 。



在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。为了解决上述问题，将函数定义为纯虚函数，则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。



将函数定义为纯虚函数能够说明，该函数为后代类型提供了可以覆盖的接口，但是这个类中的函数绝不会调用。声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。必须在继承类中重新声明函数（不要后面的＝0）否则该派生类也不能实例化，而且它们在抽象类中往往没有定义。



定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。

```C++
//抽象类
class Person{
    public:
        //纯虚函数
        virtual void GetName()=0;
};
class Student:public Person{
    public:
        Student(){
        };
        void GetName(){
            cout<<"StudentName:xiaosi"<<endl;
        };
};
int main(){
    Student student;
}
```

### 虚函数的原理：虚表/虚指针详解

为了实现C++的多态，C++使用了一种动态绑定的技术。这个技术的核心是虚函数表（下文简称虚表）。



每个包含了虚函数的类都包含一个虚表。



我们知道，当一个类（A）继承另一个类（B）时，类A会继承类B的函数的调用权。所以如果一个基类包含了虚函数，那么其继承类也可调用这些虚函数，换句话说，一个类继承了包含虚函数的基类，那么这个类也拥有自己的虚表，无论它是否使用`virtual`或是`override`关键字，又是未重写虚函数。



我们来看以下的代码。类A包含虚函数`vfunc1`，`vfunc2`，由于类A包含虚函数，故类A拥有一个虚表。

```c++
class A {
public:
    virtual void vfunc1();
    virtual void vfunc2();
    void func1();
    void func2();
private:
    int m_data1, m_data2;
};
```

![img](https://pic3.zhimg.com/80/v2-e864f4fe6a480b3230a5c9aebd7df996_720w.webp)



虚表是一个**指针数组**，其元素是虚函数的指针（也就是**虚函数的函数指针**），每个元素对应一个虚函数的函数指针。需要指出的是，普通的函数即非虚函数，其调用并不需要经过虚表，所以虚表的元素并不包括普通函数的函数指针。



虚表内的条目的赋值，**即虚函数指针的赋值发生在编译器的编译阶段**，也就是说在代码的编译阶段，虚表就可以构造出来了。



**虚表是属于类的**，而不是属于某个具体的对象，一个类只需要一个虚表即可。**同一个类的所有对象都使用同一个虚表。**



这里引入虚表指针的概念，不同于虚表，**虚表指针是属于一个类对象的**。



为了指定对象的虚表，对象内部包含一个虚表的指针，来指向自己所使用的虚表。为了让每个包含虚表的类的对象都拥有一个虚表指针，编译器在类中添加了一个指针，`*__vptr`，用来指向虚表。这样，当类的对象在创建（使用**构造函数**进行初始化对象）时便拥有了这个指针，构造函数把这个指针的值会自动被设置为指向**类的虚表**。



![img](https://pic2.zhimg.com/80/v2-0fceb07713e411d48b4c361452129585_720w.webp)



下面说明如何进行实现动态绑定，先看下面的代码。

```c++
class A {
public:
    virtual void vfunc1();
    virtual void vfunc2();
    void func1();
    void func2();
private:
    int m_data1, m_data2;
};
class B : public A {
public:
    virtual void vfunc1();
    void func1();
private:
    int m_data3;
};
class C: public B {
public:
    virtual void vfunc2();
    void func2();
private:
    int m_data1, m_data4;
};
```

类A是基类，类B继承类A，类C又继承类B。类A，类B，类C，其对象模型如下图3所示。

![img](https://pic3.zhimg.com/80/v2-dfe4aefdee7e06cf3151b57492ed42a2_720w.webp)





由于这三个类都有虚函数，故编译器为每个类都创建了一个虚表，即类A的虚表（A vtbl），类B的虚表（B vtbl），类C的虚表（C vtbl）。类A，类B，类C的对象都拥有一个虚表指针，`*__vptr`，用来指向自己所属类的虚表。



类A包括两个虚函数，故A vtbl包含两个指针，分别指向`A::vfunc1()`和`A::vfunc2()`。

类B继承于类A，故类B可以调用类A的函数，但由于类B重写了`B::vfunc1()`函数，故B vtbl的两个指针分别指向`B::vfunc1()`和`A::vfunc2()`。



类C继承于类B，故类C可以调用类B的函数，但由于类C重写了`C::vfunc2()`函数，故C vtbl的两个指针分别指向`B::vfunc1()`（指向继承的最近的一个类的函数）和`C::vfunc2()`。



虽然图3看起来有点复杂，但是只要抓住“**对象的虚表指针用来指向自己所属类的虚表，虚表中的指针会指向其继承的最近的一个类的虚函数**”这个特点，便可以快速将这几个类的对象模型在自己的脑海中描绘出来。



非虚函数的调用不用经过虚表，故不需要虚表中的指针指向这些函数。



假设我们定义一个类B的对象`bObject`。由于`bObject`是类B的一个对象，故`bObject`包含一个虚表指针，指向类B的虚表。

```C++
int main() 
{
    B bObject;
}
```

现在，我们声明一个类A的指针p来指向对象`bObject`。虽然`p`是基类的指针只能指向基类的部分，但是**虚表指针亦属于基类部分**，所以`p`可以访问到对象`bObject`的虚表指针。`bObject`的虚表指针指向类B的虚表，所以`p`可以访问到B vtbl。如图3所示。

```c++
int main() 
{
    B bObject;
    A *p = & bObject;
}
```

当我们使用`p`来调用`vfunc1()`函数时，会发生什么现象？

```C++
int main() 
{
    B bObject;
    A *p = & bObject;
    p->vfunc1();
}
```

程序在执行`p->vfunc1()`时，会发现`p`是个指针，且调用的函数是虚函数，接下来便会进行以下的步骤。



首先，根据虚表指针`p->__vptr`来访问对象`bObject`对应的虚表。虽然指针`p`是基类`A*`类型，但是`*__vptr`也是基类的一部分，所以可以通过`p->__vptr`可以访问到对象对应的虚表。



然后，在虚表中查找所调用的函数对应的条目。由于虚表在编译阶段就可以构造出来了，所以可以根据所调用的函数定位到虚表中的对应条目。对于`p->vfunc1()`的调用，B vtbl的第一项即是`vfunc1`对应的条目。



最后，根据虚表中找到的函数指针，调用函数。从图3可以看到，B vtbl的第一项指向`B::vfunc1()`，所以`p->vfunc1()`实质会调用`B::vfunc1()`函数。



如果`p`指向类A的对象，情况又是怎么样？

```C++
int main() 
{
    A aObject;
    A *p = &aObject;
    p->vfunc1();
}
```

当`aObject`在创建时，它的虚表指针`__vptr`已设置为指向A vtbl，这样`p->__vptr`就指向A vtbl。`vfunc1`在A vtbl对应在条目指向了`A::vfunc1()`函数，所以`p->vfunc1()`实质会调用`A::vfunc1()`函数。



可以把以上三个调用函数的步骤用以下表达式来表示：

```c++
(*(p->__vptr)[n])(p)
```

可以看到，通过使用这些虚函数表，即使使用的是基类的指针来调用函数，也可以达到正确调用运行中实际对象的虚函数。



我们把经过虚表调用虚函数的过程称为动态绑定，其表现出来的现象称为运行时多态。动态绑定区别于传统的函数调用，传统的函数调用我们称之为静态绑定，即函数的调用在编译阶段就可以确定下来了。



那么，什么时候会执行函数的动态绑定？这需要符合以下三个条件。

- 通过指针来调用函数
- 指针upcast向上转型（继承类向基类的转换称为upcast，关于什么是upcast，可以参考本文的参考资料）
- 调用的是虚函数



如果一个函数调用符合以上三个条件，编译器就会把该函数调用编译成动态绑定，其函数的调用过程走的是上述通过虚表的机制。



再引入纯虚函数的概念。纯虚函数不可以实例化，但是可以用其派生类实例化，示例如下：

```c++
class Base { 
    public:  
    	virtual void func() = 0;
}; 
```

```c++
#include<iostream>  
using namespace std; 
class Base {     
    public:    
    	virtual void func() = 0; 
}; 
class Derived :public Base {  
    public:   
        void func() override     {    
            cout << "哈哈" << endl;    
        } 
};
int main() {   
    Base *b = new Derived();  
    b->func();   
    return 0; 
}
```

类中含有纯虚函数时，其虚表不完全，有个空位。



即“纯虚函数在类的虚表中对应的表项被赋值为0。也就是指向一个不存在的函数。由于编译器绝对不允许有调用一个不存在的函数的可能，所以该类不能生成对象。在它的派生类中，除非重写此函数，否则也不能生成对象。”，**所以纯虚函数不能实例化**。



另外，纯虚函数是在基类中声明的虚函数，它要求**任何派生类都要定义自己的实现方法**，以实现多态性。



定义纯虚函数是为了实现一个接口，用来规范派生类的行为，也即规范继承这个类的程序员必须实现这个函数。派生类仅仅只是继承函数的接口。纯虚函数的意义在于，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但基类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。



C++中虚函数与纯虚函数的区别：

1. 虚函数和纯虚函数可以定义在同一个类中，含有纯虚函数的类被称为抽象类，而只含有虚函数的类不能被称为抽象类。
2. 虚函数可以被直接使用，也可以被子类重载以后，以多态的形式调用，而纯虚函数必须在子类中实现该函数才可以使用，因为纯虚函数在基类有声明而没有定义。
3. 虚函数和纯虚函数都可以在子类中被重载，以多态的形式被调用。
4. 虚函数和纯虚函数通常存在于抽象基类之中，被继承的子类重载，目的是提供一个统一的接口。
5. 在虚函数和纯虚函数的定义中不能有static标识符，原因很简单，被static修饰的函数在编译时要求前期绑定，然而虚函数却是动态绑定，而且被两者修饰的函数生命周期也不一样。

### 说说 C++ 中什么是菱形继承问题，如何解决

下面的图表可以用来解释菱形继承问题。



![img](https://uploadfiles.nowcoder.com/images/20220225/4107856_1645788250019/669F46EC1CA09D9F687FFD9A8EC4CFEE)

假设我们有类B和类C，它们都继承了相同的类A。另外我们还有类D，类D通过多重继承机制继承了类B和类C。因为上述图表的形状类似于菱形，因此这个问题被形象地称为菱形继承问题。现在，我们将上面的图表翻译成具体的代码：

```c++
/*  *Animal类对应于图表的类A* */ 
class Animal {
    int weight;    
 public:   
 	int getWeight() { return weight; } 
};  
class Tiger : public Animal { /* ... */ }; 
class Lion : public Animal { /* ... */ } 
class Liger : public Tiger, public Lion { /* ... */ }
```

在上面的代码中，我们给出了一个具体的菱形继承问题例子。Animal类对应于最顶层类（图表中的A），Tiger和Lion分别对应于图表的B和C，Liger类（狮虎兽，即老虎和狮子的杂交种)对应于D。



现在，问题是如果我们有这种继承结构会出现什么样的问题。看看下面的代码后再来回答问题吧。

```c++
 int main( )  { 
     Liger lg;   /*编译错误，下面的代码不会被任何C++编译器通过 */   
     int weight = lg.getWeight();  
 }
```

在我们的继承结构中，我们可以看出Tiger和Lion类都继承自Animal基类。所以问题是：因为Liger多重继承了Tiger和Lion类，因此Liger类会有两份Animal类的成员（数据和方法），Liger对象"lg"会包含Animal基类的两个子对象。



所以，你会问Liger对象有两个Animal基类的子对象会出现什么问题？再看看上面的代码-调用`lg.getWeight()`将会导致一个编译错误。这是因为编译器并不知道是调用Tiger类的`getWeight()`还是调用Lion类的`getWeight()`。所以，调用`getWeight()`方法是不明确的，因此不能通过编译。



我们给出了菱形继承问题的解释，但是现在我们要给出一个菱形继承问题的解决方案。如果Lion类和Tiger类在分别继承Animal类时都用virtual来标注，对于每一个Liger对象，C++会保证只有一个Animal类的子对象会被创建。看看下面的代码:

```c++
class Tiger : virtual public Animal { /* ... */ }; 
class Lion : virtual public Animal { /* ... */ };
```

你可以看出唯一的变化就是我们在类Tiger和类Lion的声明中增加了"virtual"关键字。现在类Liger对象将会只有一个Animal子对象，下面的代码编译正常:

```c++
int main( ) {  
    Liger lg;  /*既然我们已经在Tiger和Lion类的定义中声明了"virtual"关键字，于是下面的代码编译OK */  
    int weight = lg.getWeight(); 
}
```

虚继承是解决C++多重继承问题的一种手段，从不同途径继承来的同一基类，会在子类中存在多份拷贝。

### 请问构造函数中的能不能调用虚方法 777

不要在构造函数中调用虚方法，从语法上讲，调用完全没有问题，但是从效果上看，往往不能达到需要的目的。派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。



同样，进入基类析构函数时，对象也是基类类型。所以，虚函数始终仅仅调用基类的虚函数（如果是基类调用虚函数），不能达到多态的效果，所以放在构造函数中是没有意义的，而且往往不能达到本来想要的效果。

### 请问拷贝构造函数的参数是什么传递方式，为什么 777

拷贝构造函数的参数必须使用引用传递。



如果拷贝构造函数中的参数不是一个引用，即形如`CClass(const CClass c_class)`，那么就相当于采用了传值的方式(`pass-by-value`)，而传值的方式会调用该类的拷贝构造函数，从而造成无穷递归地调用拷贝构造函数。因此拷贝构造函数的参数必须是一个引用。



需要澄清的是，传指针其实也是传值，如果上面的拷贝构造函数写成`CClass(const CClass* c_class)`，也是不行的。事实上，只有传引用不是传值外，其他所有的传递方式都是传值。

### 简述一下拷贝赋值和移动赋值 777

拷贝赋值是通过拷贝构造函数来赋值，在创建对象时，使用同一类中之前创建的对象来初始化新创建的对象。



移动赋值是通过移动构造函数来赋值，二者的主要区别在于：

- 拷贝构造函数的形参是一个左值引用，而移动构造函数的形参是一个右值引用；

- 拷贝构造函数完成的是整个对象或变量的拷贝，而移动构造函数是生成一个指针指向源对象或变量的地址，接管源对象的内存，相对于大量数据的拷贝节省时间和内存空间。



