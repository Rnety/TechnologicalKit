

# 排序

## 算法

### 时间复杂度

时间复杂度取决于常数时间的操作。一个操作如果和样本的数据量没有关系，每次都是固定时间内完成的操作，叫做常数操作。具体来说，先要对一个算法流程非常熟悉，然后去写出这个算法流程中，发生了多少常数操作，进而总结出常数操作数量的表达式。



时间复杂度为一个算法流程中，常数操作数量的一个指标。在表达式中，只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分如果为f(N)，那么时间复杂度为0(f(N))。评价一个算法流程的好坏，先看时间复杂度的指标，然后再分析不同数据样本下的实际运行时间，也就是“常数项时间”。当两个算法的时间复杂度为同量级的时候，需要在不同环境下进行测试运行时间来选出更适合的算法。

​	

例如，数组即在内存的连续存储的内存单元结构当中，对其中某个内存单元的操作都可以直接进行，具有随机存取的特性，对数组元素的操作时间复杂度为O(1)。链表即在内存当中非连续存储的内存单元结构当中，需要先找到前一个链表元素在内存的中的位置，不具有随机存储的特性，对链表元素的操作时间复杂度为O(n)。

### 空间复杂度

空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度。空间复杂度不是程序占用了多少字节的空间，因为这个也没太大意义，所以空间复杂度算的是变量的个数。空间复杂度计算规则基本跟时间复杂度类似。

## 简单选择排序

简单选择排序：每次在未排序序列中选择最小的元素与未排序序列第一个位置元素进行交换，然后将未排序序列第一个位置元素加入已排序序列的最后一个元素。其中常数时间的操作分为找元素、比较元素、交换元素（每次次数如下表所示）。则最后常数时间的操作最高次项n<sup>2</sup>，时间复杂度为O(n<sup>2</sup>)。

| 次数 | 找元素 | 比较次数 | 交换次数 |
| ---- | ------ | -------- | -------- |
| 1    | n      | n        | 1        |
| 2    | n-1    | n-1      | 1        |
| ...  | ...    | ...      | ...      |

```c++
void selectionSort(vector<int> cnt)
{
    if (cnt.size() < 2)
    {
        return;
    }
    for (int i = 0; i < cnt.size(); i++)
    {
        int minIndex = i;
        for (int j = i + 1; j < cnt.size(); j++)
        {
            minIndex = cnt[j] < cnt[minIndex] ? j : minIndex;
        }
        swap(cnt[i], cnt[minIndex]);
    }
}
```

## 冒泡排序

冒泡排序：从未排序序列中两两进行比较，大的元素被交换在后。其中常数时间的操作分为找元素、比较元素、交换元素（每次次数如下表所示）。则最后常数时间的操作最高次项n<sup>2</sup>，时间复杂度为O(n<sup>2</sup>)。

| 次数 | 找元素 | 比较次数 | 交换次数 |
| ---- | ------ | -------- | -------- |
| 1    | n      | n-1      | 1        |
| 2    | n-1    | n-2      | 1        |
| ...  | ...    | ...      | ...      |

```c++
void bubbleSort(vector<int> cnt)
{
    if (cnt.size() < 2)
    {
        return;
    }
    for (int i = cnt.size() - 1; i > 0; i--)
    {
        for (int j = 0; i < i; j++)
        {
            if (cnt[j] > cnt[j + 1])
            {
                swapCnt(cnt, i, i + 1);
            }
        }
    }
}
void swapCnt(vector<int> cnt, int i, int j)
{
    cnt[i] = cnt[i] ^ cnt[j];
    cnt[j] = cnt[i] ^ cnt[j];
    cnt[i] = cnt[i] ^ cnt[j];
}
```

## 位运算

介绍异或操作下进行元素交换的原理。首先保证异或操作的交换的两个元素位于不同的内存单元。
异或是一个经典的计算机操作，相同为0，不同为1，异或可视为无进位相加。**异或的运算规律如下：**

- 异或自己为0，异或0为自己
- 异或满足交换律和结合律
- 同一批数的异或结果一致



在这种结构下异或可以处理一些算法中的位运算问题。下面对异或的位运算的算法题进行解析：

1. 在数组当中存在**一个数为奇数次，其他数均为偶数次**，求出该奇数次的数
2. 在数组当中存在**两个不同数为奇数次，其他数均为偶数次**，求出该奇数次的数



当在数组当中存在**一个数为奇数次，其他数均为偶数次**：

1. 暴力算法即定义两个for循环，进行数组的遍历直到找出对应的数，则最后常数时间的操作最高次项n<sup>2</sup>，时间复杂度为O(n<sup>2</sup>)。
2. 而使用异或，遍历数组可直接得到，时间复杂度为O(n)。

```c++
void OddOneTimeNum(vector<int> cnt)
{
    int ans = 0;
    for (int cur : cnt)
    {
        ans ^= cur;
    }
    cout << ans;
}
```



当在数组当中存在**两个不同数为奇数次，其他数均为偶数次**:

1) 暴力算法。即定义两个for循环，进行数组的遍历直到找出对应的数，则最后常数时间的操作最高次项n<sup>2</sup>，时间复杂度为O(n<sup>2</sup>)。

2. 使用异或。假设存在这两个不同数分别为a，b，异或遍历数组后可得到a^b，已知a，b为两个不同的数，则 a^b一定不为0。假设这个数组的数据类型为int，则在内存中以用32位二进制存储。 a^b 在32位二进制存储位中为1的位置上，a与b是该位置存储位的一定为一个是1另一个是0。把数组分为两类，一类是该二进制位上为1，另一类为该二进制位上为0。设置新变量异或数组中元素在32位二进制存储位为1的元素，则可以得到a或b，出现偶数次的数依然异或成0，再用该变量异或a^b得到另一个数。

```c++
void OddTwoTimeNum(vector<int> cnt)
{
    int ans = 0;
    for (int cur : cnt)
    {
        ans ^= cur;
    }
    int rightOne = ans & (~ans + 1); // 取反，加1，与操作，得到一个数最右侧的1
    int Onlyone = 0;
    for (int cur : cnt)
    {
        if ((cur & rightOne) == 0)
        {
            Onlyone ^= cur;
        }
    }
    cout << Onlyone << " " << (ans ^ Onlyone);
}
```

## 插入排序

插入排序：从无序数列中进行依次插入到有序序列当中。则最后常数时间的操作最高次项n<sup>2</sup>，时间复杂度为O(n<sup>2</sup>)。最快可到O(n)的时间复杂度。

```c++
void insertionSort(vector<int> cnt)
{
    if (cnt.size() < 2)
    {
        return;
    }
    for (int i = 1; i < cnt.size(); i++)
    {
        for (int j = i - 1; j >= 0 && cnt[j] > cnt[j + 1]; j--)
        {
            swap(cnt[j], cnt[j + 1]);
        }
    }
}
```

## 二分法的详解和扩展

左右两侧与所求问题有关且明显可以甩掉一边的问题。

1. **在一个有序数组中，找某个数是否存在。**

   使用折半查找，其核心思想是二分法，直到找到/找不到结束。时间复杂度为O(log<sub>2</sub>n)。

2. **在一个有序数组中，找>=某个数的最左侧的位置。**

   使用折半查找，其核心思想是二分法，直到整个二分到结束，设置变量t记录的最左位置，时间复杂度为O(log<sub>2</sub>n)。

3. **在一个无序数组当中，相邻数一定不相等的局部最小值问题。局部最小的定义为：**

   **1、0位置的数小于1位置的数则其为局部最小。**

   **2、N-1位置的数小于N-2位置上的数则N-1位置的数为局部最小。**

   **3、i位置的数比i-1位置与i+1位置的数都小则为局部最小。**

   其核心思想是二分法。先判断0位置或者N-1的位置是否是局部最小，是则直接返回。如果不是则局部最小一定在与中间部分，依然可以使用二分法。

## 对数器的概念和使用

1. 有一个你想要测的方法a。
2. 实现复杂度不好但是容易实现的方法b。
3. 实现一个随机样本产生器。
4. 把方法a和方法b跑相同的随机样本，看看得到的结果是否一样。
5. 如果有一个随机样本使得比对结果不一致，打印样本进行人工干预改对方法a或者方法b。
6. 当样本数量很多时比对测试依然正确，可以确定方法a已经正确。

## 递归

### 递归行为

以一个递归方式求数组中的最大值的方法举例递归执行。

```java
//arr[L...R]范围上的最大值
public static int process(int[] arr,int L,int R){
    if(L==R){
        return arr[L];
    }
    int mid = L + ( ( R - L ) >> 1);//右移一位
    int leftMax = process(arr, L, mid);
    int rightMax = process(arr, mid+1, R);
    return Math.max(leftMax,rightMax);
}

public static int getMax(int[] arr){
    return process(arr, 0, arr.length-1);
}
```

**注意：**假如`mid`的求法为`mid=(L+R)/2`时候`L+R`有可能会溢出，因此应写为`mid=L+(R-L)/2`，更快的写法为`mid = L + ( ( R - L ) >> 1)`。



整个递归是利用系统栈对该二叉树进行后序遍历，栈空间即树高。

### master公式

对于等规模的递归求解时间复杂度，Master公式应运而生。Master公式如下：

![T(N) = a*T(\frac{N}{b}) + O(N^d)](https://math.jianshu.com/math?formula=T(N)%20%3D%20a*T(%5Cfrac%7BN%7D%7Bb%7D)%20%2B%20O(N%5Ed))

其中`N`为母问题的规模，`N/b`为子问题的规模，`a`为子问题被调用的次数，`d`为额外操作的次数。显而易见，在例子中，是满足Master公式的。



- 当log<sub>b</sub>a < d时，时间复杂度为O(N<sup>d</sup>)
- 当log<sub>b</sub>a > d时，时间复杂度为O(N<sup>log<sub>b</sub>a</sup>)
- 当log<sub>b</sub>a = d时，时间复杂度为O(N<sup>d</sup> * logN)

## 归并排序

归并排序的代码可同下编写，显然a=2，b=2，d=1，时间复杂度为O(NlogN)，而空间复杂度为O(n)。

```java
public static void process(int[] arr,int L,int R){
    if(L==R){
        return arr[L];
    }
    int mid = L + ( ( R - L ) >> 1);//右移一位
    process(arr, L, mid);
    process(arr, mid+1, R);
    merge(arr, L, mid, R);
}

public static void merge(int[] arr,int L,int M, int R){
   	int[] help = new int(R - L + i);//最多n个空间反复利用，空间复杂度为O(n)。
    int i = 0;
    int p1 = L;
    int p2 = M + 1;
    while(p1 <= M && p2 <= R){
        help[i++] = arr[p1] <= arr[p2]? arr[p1++] :arrr[p2++];
    }
    while(p1 <= M){
        help[i++] = arr[p1++];
    }
    while(p2 <= R){
        help[i++] = arr[p2++];
    }
    for(i = 0; i < arr.length; i++){ //把整个数组拷贝回原数组
        arr[L + i] =help[i];
    }
}
```

相对于O(n<sup>2</sup>)，O(NlogN)的算法减少的绝大量多余的、浪费的比较行为，其比较行为的信息保留了，这是高效的。

### 小和问题

在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。



转为求一个数的右边有多少个数比它大，利用归并排序可以不遗漏，不重算的快速解决该问题。

```java
public static int smallSum(int[] arr){
    if(arr == null || arr.length < 2){
        return 0;
    }
    return process(arr, 0, arr.length-1);
}

public static int process(int[] arr,int L,int R){
    if(L==R){
        return 0;
    }
    int mid = L + ( ( R - L ) >> 1);//右移一位
    return process(arr, L, mid) //左侧小和
    	   + process(arr, mid+1, R) //右侧小和 
           + merge(arr, L, mid, R); //合并小和
}

public static int merge(int[] arr,int L,int M, int R){
   	int[] help = new int(R - L + i);
    int i = 0;
    int p1 = L;
    int p2 = M + 1;
    int res = 0;
    while(p1 <= M && p2 <= R){
        res += arr[p1] < arr[p2] ? (R - p2 + 1) * arr[p1] : 0;
        help[i++] = arr[p1] < arr[p2]? arr[p1++] :arrr[p2++];
    }
    while(p1 <= M){
        help[i++] = arr[p1++];
    }
    while(p2 <= R){
        help[i++] = arr[p2++];
    }
    for(i = 0; i < arr.length; i++){ //把整个数组拷贝回原数组
        arr[L + i] =help[i];
    }
    return res;
}
```

相对于暴力算法的O(n<sup>2</sup>)，该方法将时间复杂度提升到了O(NlogN)，以下标的方式解决了重复多余的比较操作。

### 逆序对问题

在一个数组中，左边的数如果比右边的数大，则折两个数构成一个逆序对，请打印所有逆序对。



转为求一个数的右边有多少个数比它小，与小和问题一致。



## 快速排序

### 荷兰国旗问题1.0

给定一个数组arr，和一个数num，请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。要求额外空间复杂度0(1)，时间复杂度0(N)。



设定小于等于区域初始为-1。



1、设定小于等于区域初始为-1，当前数小于等于num时候，当前数与小于等于区域的下一个进行交换，小于等于区域右扩，i++。



2、当前数大于num的时候，i++。

### 荷兰国旗问题2.0



给定一个数组arr，和一个数num，请把小于num的数放在数组的左边，等于num的数放在数组的中间，大于num的数放在数组的右边。要求额外空间复杂度0(1)，时间复杂度0(N)。



设定小于等于区域初始为-1，大于区域初始为arr.length。



1、当前数小于等于num时候，当前数与小于等于区域的下一个进行交换，小于等于区域右扩，i++。



2、当前数等于num的时候，i++。



3、当前数大于num的时候，i与大于区域的前一个进行交换，大于区域左扩，i不变。



实质上，将数组分为三个区间：小于、等于、大于。当出现小于的时候，直接扩展小于区域，把等于区域往右推。当出现大于的时候，交换后扩展大于区域，把等于区域往左推，重新观察交换过来的数应在的位置。



**快排的思想就是在荷兰国旗问题上。**



快排的**起始**，在于荷兰国旗问题1.0，默认把num设置为数组的最后一个数，依次把左右两个区间的数进行排序之后，把最后一个数与大于区间上的第一个数进行交换，最后依次对左右两个区间进行递归，得到有序数组。



快排的**进阶**，在于荷兰国旗问题2.0，默认把num设置为数组的最后一个数，依次把三个区间的数进行排序之后，把最后一个数与大于区间上的第一个数进行交换，此时一次排序完成了一片相等的区域，最后依次对左右两个区间进行递归，得到有序数组。



以上的最坏情况下是完全有序的数据下，快排的时间复杂度是O(n<sup>2</sup>)。最坏的情况是由于划分值非常的偏，导致出现了快排的时间复杂度是O(n<sup>2</sup>)。



快排的**最优**，是利用随机性选择下的一个数与最后一个数进行交换后，进行快排。此时的好情况和坏情况为等概率事件，在这样的情况下，以数学期望下的计算下，时间复杂度为O(NlogN)。



```java
public static void quickSort(int[] arr){
    if(arr == null|| arr.length < 2){
        return;
    }
    quickSort(arr, 0, arr.length -1);
}

public static void quickSort(int[] arr, int L, int R){
    if(L < R){
        swap(arr, L + (int)(Math.random() * (R - L + 1)), R);
        int[] p = partition(arr, L, R); //返回划分值小于区域和大于区域的两个边界
        quickSort(arr, L, p[0]-1); //<区
        quickSort(arr, p[1]+1, R); //>区
    }
}

public static int[] partition(int[] arr, int L, int R){
    int less = L - 1; //<区右边界
    int more = R; //>区左边界
    while(L < more){ //L表示当前数的位置 arr[R]为划分值
        if(arr[L] < arr[R]){ //当前数 < 划分值
            swap(arr, ++less, L++);
        }else if(arr[L] > arr[R]){ //当前数 > 划分值
            swap(arr, --more, L);
        }else{
            L++;
        }
    }
    swap(arr, more, R);
    return new int[] { less + 1, more };
}
```

最差的情况是该序列是有序的，空间复杂度为O(N)。好的情况是每次选的为中点为划分值，形成一颗二叉树，空间对应树高，空间复杂度为O(logN)。且利用非递归的方法写不能减少空间复杂度，中点的位置需要记录，迭代同样需要自己压栈，空间的复杂度是无法减少。在数学期望下，空间复杂度为

空间复杂度为O(logN)。

## 堆

堆在实质上是用数组实现的完全二叉树结构。完全二叉树中如果每棵子树的最大/小值都在顶部就是大/小根堆。

### 堆操作

下面以大顶堆进行代码实现。



1、大顶堆的建立、插入（heaplnsert) ，时间复杂度为O（logN），对应树高。当`index=0`的时候，`(index-1)/2`为0。

```java
public static void heapInsert(int[] arr, int index){
    while(arr[index] > arr[ (index - 1) / 2]){ 
        swap(arr, index, (index - 1) / 2);
        index = (index - 1) / 2;
    }
}
```

2、某个位置在index位置，能否向下移动（heapify），时间复杂度为O（logN），对应树高。

```java
public static heapify(int[] arr, int index, int heapSize){
    int left = index * 2 + 1; //左孩子
    while(left < heapSize){ //下方还有孩子的时候
        int largest = left + 1 < heapSize && arr[left + 1] > arr[left]? left + 1 : left;
        largest = arr[largest] > arr[index] ? largest : index;
        if(largest == index){
            break;
        }
        swap(arr, largest, index);
        index = largest;
        left = index * 2 + 1;
    }
}
```

3、堆排序，时间复杂度为O(NlogN)，空间复杂度为O(1)。

```java
public static void heapSort(int[] arr){
    if(arr == null || arr.length < 2){
        return;
    }
    for(int i = 0; i < arr.length; i++){
        heapInsert(arr,i);
    }
    int heapSize = arr.length;
    swap(arr, 0, --heapSize);
    while(heapSize > 0){
        heapify(arr, 0, heapSize);
        swap(arr, 0, --heapSize);
    }
}
```

假设假设用户提供完全的一个完全二叉树时候，只需在最后一个非叶节点进行heapify，然后依次往前做heapify时，可形成堆排序。

```java
public static void heapSort(int[] arr){
    if(arr == null || arr.length < 2){
        return;
    }
    for(int i = arr.length - 1 ; i >= 0; i--){
       heapify(arr, i, arr.lenth); //O(N)
    }
    int heapSize = arr.length;
    swap(arr, 0, --heapSize);
    while(heapSize > 0){
        heapify(arr, 0, heapSize);
        swap(arr, 0, --heapSize);
    }
}
```



此时对应满二叉树性质，满二叉树的叶子节点为N/2个，时间复杂度计算如下：

1、T(N) = N/2 * 1 +N/4 * 2 + N/8 * 3 +.... 等式两边乘2

2、2T(N) = N/2 * 2 +N/2 * 2 + N/4 * 3 +.... 2式减1式

3、T(N) = N + N/2  + N/4 + N/8 +....

综上第一步的时间复杂度为O(N)，但总体时间复杂度为O（NlogN）。

### 堆结构

优先级队列的实质上是一个大顶堆。



当不够用的时候，扩容是以倍数为边界，假设heapSize为100，扩容为heapSize为200，即2N，每次扩容（移动）的时间复杂度为O(n)，每次需要O(logN)的heapify进行整理，综合每一个元素导致形成的时间复杂度为O(logN)。



系统的堆的内部变值是难以实现的，难以高效。多数的情况下需要手写堆才能获得更好的时间复杂度。



已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的排序算法针对这个数据进行排序。



这个问题即堆排序的扩展，令`k=heapSize`后，建立好小堆后把去除堆顶，依次放入数组有序区间，再把后一个数依次进行堆插入，最后得到有序序列。



```java
public void sortedArrDistanceLessK(int[] arr, int k){
    PriorityQueue<Integer> heap = new  PriorityQueue<>;
    int index = 0;
    for(; index <= Math.min(arr.length, k); index++){ //防止k是无穷
        heap.add(arr[index]);
    }
    int i = 0;
    for(; index < arr.length; i++,index++){
        heap.add(arr[index]);
        arr[i] = heap.poll();
    }
    while(!heap.isEmpty()){
        arr[i++] = heap.poll();
    }
}
```

## 比较器的使用

1、比较器的实质就是重载比较运算符，重载了比较的方式。重载的后在比较的时候加入自定义的比较器即可。可以自己定义一个复杂数据类型的比较器或者复杂比较规则。

- 返回负数的时候，第一个参数排在前面
- 返回正数的时候，第二个参数排在前面
- 返回0的时候，谁在前面无所谓



2、比较器可以很好的应用在特殊标准的排序上。



3、比较器可以很好的应用在根据特殊标准排序的结构上，例如堆。



以上的排序只和比较有关，上面的排序被称为基于比较的排序。

## 桶排序

不基于比较的排序，即利用空间换时间。

### 计数排序

利用外部空间的数组进行存储信息，直接遍历一次可得到时间复杂度为O(N)。



但假设这个范围过大，会导致时间复杂度也很大。这是有局限的数据状况来进行排序。

### 基数排序

将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。



从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。



但假设这个范围过大，会导致时间复杂度也很大。这是有局限的数据状况来进行排序。



```java
public static int maxbits(int[] arr){ //找到最大值的十进制位数
    int max = Integer.MIN_VALUE;
    for(int i = 0 ; i < arr.length; i++){
        max = Math.max(max,arr[i]);
    }
    int res = 0;
    while(max != 0){
        res++;
        max /= 10;
    }
    return res;
}

public static void radixSort(int[] arr, int L, int R, int digit){ //这一批数字中有多少个10进制位
    final int radix = 10; //以10为基底
    int i = 0, j = 0;
    int bucket = new int[R - L + i];//有几个数就准备多少个辅助空间
    for(int d = 1 ; d <= digit ;d++){//入桶出通由十进制位数决定
        int[] count = new int[radix];
        for(i = L; i <= R; i++){ //累计当前轮的计数
            j = getDigit(arr[i], d);//d是1取出个位，d是2取出十位...
            count[j]++;
        }
        for(i = 1; i< radix; i++){ //计算前缀和
            count[i] = count[i] + count[i - 1];
        }
        for(i = R; i >= L; i--){ //逆序出桶
            j = getDigit(arr[i], d);
            bucket[count[j] - 1] = arr[i];
            count[j]--;
        }
        for(i = L, j = 0; j <= R; i++, j++){ //整理该轮
            arr[i] = bucket[j]
        }
    } 
}
```

## 排序算法的稳定性及其汇总

稳定性：同样值的个体之间，如果不因为排序而改变相对次序，就是这个排序是有稳定性的；否则就没有。稳定性在非基础类型的数据分类中是刚需的。



选择排序： 序列3333313333显然做不到稳定性。

冒泡排序： 序列只要相等的时候不要求交换即可实现稳定性。

插入排序： 序列只要相等的时候不要求交换即可实现稳定性。



归并排序： 只要相等的时候先拷贝左侧的时即可实现稳定性。

快速排序： 当num=5时候，情况一的序列67663显然做不到稳定性。情况二的序列55553显然也做不到稳定性。

堆排序： 序列544在插入6的时候显然做不到稳定性。



计数、基数排序均为先入桶的先出桶，显然能做到稳定性。

| 排序 | 时间复杂度       | 空间复杂度 | 稳定性 |
| ---- | ---------------- | ---------- | ------ |
| 选择 | O(N<sup>2</sup>) | O(1)       | No     |
| 冒泡 | O(N<sup>2</sup>) | O(1)       | Yes    |
| 插入 | O(N<sup>2</sup>) | O(1)       | Yes    |
| 归并 | O(N*logN)        | O(N)       | Yes    |
| 快排 | O(N*logN)        | O(logN)    | No     |
| 堆   | O(N*logN)        | O(1)       | No     |

目前没有找到时间复杂度O(N*logN)，额外空间复杂度0(1)，又稳定的排序。

### 常见的坑

- 归并排序的额外空间复杂度可以变成O(1)，但是非常难，不需要掌握，有兴趣可以搜“归并排序内部缓存法”。

- “原地归并排序”的帖子都是垃圾，会让归并排序的时间复杂度变成O(N<sup>2</sup>)。

- 快速排序可以做到稳定性问题，但是非常难，不需要掌握，可以搜“01 stable sort”，但空间复杂度O(N)。

- 所有的改进都不重要，因为目前没有找到时间复杂度O(N*logN)，额外空间复杂度0(1)，又稳定的排序。
- 有一道题目，是奇数放在数组左边，偶数放在数组右边，还要求原始的相对次序不变，碰到这个问题，可以怼面试官。快排的实质是0/1标准的情况，但是不具有稳定性，能做到但是论文级别。

### 工程上堆排序的改进

1、充分利用O(NlogN)和O(N<sup>2</sup>)排序各自的优势。



快排的排序改进，当样本量小于60的时候，改为插入排序。当样本量过大的时候，使用快排。当样本量小于60的时候，插入排序更优。在大调度上是快排，小样本上是插入，使整体时间更少。



2、稳定性的考虑。



系统内部的`sort`是基础类型数据默认使用快速排序，非基础类型的数据默认使用归并排序，两者则基于稳定性考虑。但实质上内部的排序内部策略已经经过很多封装。

 

# 集合结构

## 哈希表

哈希表在使用层面上可以理解为一种集合结构。如果只有key，没有伴随数据value，可以使用HashSet结构（C++中叫UnOrderedSet）。

```java
HashSet<Integer> hasSet = new HashSet<>();
```

```java
hasSet.add(value);
hasSet.remove(value);
hasSet.contains(value);
```

如果既有key，又有伴随数据value，可以使用HashMap一结构（C++中叫UnOrderedMap）。有无伴随数据，是HashMap和HashSet唯一的区别，底层的实际结构是一回事。

```java
HashMap<Integer, String> hasMap = new HashMap<>();
```

```java
hasMap.put(key, value);//插入、更新（更新value）
hasMap.remove(key);
hasMap.containsKey(key);
hasMap.get(key);
```

使用哈希表增(put)、删(remove)、改(put)和查(get)的操作，可以认为时间复杂度为O(1)，但是常数时间比较大。



放入哈希表的东西，如果是基础类型，内部按值传递，内存占用就是这个东西的大小。放入哈希表的东西，如果不是基础类型，内部按引用传递，内存占用是这个东西内存地址的大小（key只占八个字节）。

## 有序表

有序表在使用层面上可以理解为一种集合结构。
如果只有key，没有伴随数据value，可以使用TreeSet结构(C++中叫OrderedSet)。

```java
TreeSet<Integer> treeSet = new TreeSet<>();
```



如果既有key，又有伴随数据value，可以使用TreeMap结构(C++中叫OrderedMap)。有无伴随数据，是TreeSet和TreeMap唯一的区别，底层的实际结构是一回事。

```java
TreeMap<Integer, String> treeMap = new  new TreeMap<>();
```

```java
treeMap.put(key, value);//插入、更新（更新value）
treeMap.remove(key);
treeMap.containsKey(key);
treeMap.get(key);
```

**有序表和哈希表的区别是，有序表把key按照顺序组织起来，而哈希表完全不组织。**意味着哈希表能实现的功能，有序表都能实现，甚至实现新功能，有序表时间复杂度都是O(NlogN)。

```java
treeMap.firstKey();//最小
treeMap.lastKey();//最大
treeMap.floorKey(key);//小于等于key离key最近
treeMap.ceilingKey(key);//大于等于key离key最近
```

红黑树、AVL树、size-balance-tree和跳表等都属于有序表结构，只是底层具体实现不同，但性能的时间复杂度都一致。



放入有序表的东西，如果是基础类型，内部按值传递，内存占用就是这个东西的大小。放入有序表的东西，如果不是基础类型，必须提供**比较器**，以告诉按照什么顺序进行组织，内部按引用传递，内存占用是这个东西内存地址的大小。



不管是什么底层具体实现，只要是有序表，都有以下固定的基本功能和固定的时间复杂度。

 

# 链表



面试时链表解题的方法论：

- 对于笔试，不用太在乎空间复杂度，一切为了时间复杂度。
- 对于面试，时间复杂度依然放在第一位，但是一定要找到空间最省的方法

重要技巧:

- 额外数据结构记录（哈希表等)
- 快慢指针

## 技巧体现

1、判断一个链表是否为回文结构。给定一个单链表的头节点head，请判断该链表是否为回文结构。如果链表长度为N，时间复杂度达到0(N)，额外空间复杂度达到0(1)。



利用栈只把右边的进行入栈保存然后从左边进行比对直到栈空，相对于全部入栈，省下一半空间。



对于单链表，进行快慢指针的解法。快指针一次性走两步，慢指针一次性走一步，当快指针走完后，慢指针恰好在中间位置。该快慢指针的解法需要根据不同情况进行定制。



但只要求有限变量的时候，找到中点以后，把后半部分的next全部逆序，且中间位置的next为空，利用快指针和头指针两个一起往中间遍历进行比较，出现结果后需要保证链表变回原样，代码复杂但是空间复杂度度却是O(1)。

```java
public static boolean isPalindrome1(Node head){ 
    Stack<Node> stack = new stack<Node>();
    Node cur = head;
    while(cur != null){
        stack.push(cur);
        cur = cur.next;
    }
    while(head != null){
        if(head.value != stack.pop().value){
            return false;
        }
        head = head.next;
    }
    return true;
}

public static boolean isPalindrome2(Node head){
    if(head == null && head.next == null){
        return true;
    }
    Node right = head.next;
    Node cur = head;
    while(cur.next != null && cur.next.next != null){
        right = right.next;
        cur = cur.next.next;
    }
    Stack<Node> stack = new stack<Node>();
    while(right != null){
        stack.push(right);
        right = right.next;
    }
    while(!stack.isEmpty()){
        if(head.value != stack.pop().value){
            return false;
        }
        head = head.next;
    }
    return true;
}

public static boolean isPalindrome3(Node head){
    if(head == null && head.next == null){
        return true;
    }
    Node n1 = head;//慢指针
    Node n2 = head;//快指针

    while(n2.next != null n2.next.next != null){ //经过大量实验
        n1 = n1.next; //n1->mid
        n2 = n2.next.next;//n2->end
    }
    n2 = n1.next; 
    n1.next = null;
    Node n3 = null;
    while(n2 != null){
        n3 = n2.next;
        n2.next = n1;
        n1 = n2;
        n2 = n3;
    }
    n3 = n1;
    n2 = head;
    boolean res = true;
    while(n1 != null && n2 != null){
        if(n1.value != n2.value){
            res = false;
            break;
        }
        n1 = n1.next;
        n2 = n2.next;
    }
    n1 = n3.next;
    n3.next = null;
    while(n1 != null){
        n2 = n1.next;
        n1.next = n3;
        n3 = n1;
        n1 = n2;
    }
    return res;
}
```



2、将单向链表按某值划分成左边小、中间相等、右边大的形式。给定一个单链表的头节点head，节点的值类型是整型，再给定一个整数pivot。实现一个调整链表的函数，将链表调整为左部分都是值小于pivot的节点，中间部分都是值等于pivot的节点，右部分都是值大于pivot的节点。



单链表放到数组内，进行快速排序，再利用头节点进行串起来。



在实现原问题功能的基础上增加如下的要求：
1、调整后所有小于pivot的节点之间的相对顺序和调整前一样

2、调整后所有等于pivot的节点之间的相对顺序和调整前一样

3、调整后所有大于pivot的节点之间的相对顺序和调整前一样

4、时间复杂度请达到o(N)，额外空间复杂度请达到0(1)。



设定6个变量：小于变量的头和尾、等于变量的头和尾、大于变量的头和尾。依次遍历单链表，依次放入各自的链表队列内最后把这几个链表队列链接，注意链接的时候讨论是否有大于、小于、等于的是否有，讨论边界，否则空指针的next出错。

```java
public static Node isPartition(Node head, int pivot){
    Node sH = null;
    Node sT = null;
    Node eH = null;
    Node eT = null;
    Node mH = null;
    Node mT = null;
    while(head != null){
        next = head.next;
        head.next = null;
        if(head.value < pivot){
         if(sH == null){
             sH = head;
             sT = head;
         }else{
             sT.next = head;
             sT = head;
         }   
        }else if{
            ....
        }else{
            ....
        }
    }
    if(sT != null){
        sT.next = eH;
        eT = eT == null ? sT :eT;
    }
    if(eT != null){
        eT.next = mH;
    }
    return sH != null ? sH :(eH != null ? eH : mH);
}
```

3、复制含有随机指针节点的链表。一种特殊的单链表节点类描述如下：

```java
class Node {
	int value;
    Node next;
    Node rand;
	Node(int val){
		value = val ;
	}
}
```


rand指针是单链表节点结构中新增的指针，rand可能指向链表中的任意一个节点，也可能指向null。给定一个由Node节点类型组成的无环单链表的头节点head，请实现一个函数完成这个链表的复制，并返回复制的新链表的头节点。要求时间复杂度O(N)，额外空间复杂度0(1)。



假如不需要空间复杂度，直接使用哈希表，形成map<key,value>其中key为原结点、value为新结点，依次设置对应的next、rand的指针指向。

```java
public static Node copyListWithRand1(Node node){
    HashMap<Node, Node>  map = new HashMap<Node, Node>;
    Node cur = head;
    while (cur != null){
        map.put(cur, new Node(cur.value));
        cur = cur.next;
    }
    cur = head;
    while(cur != null){
        map.get(cur).next = map.get(cur.next);
        map.get(cur).rand = map.get(cur.rand);
        cur = cur.next;
    }
    return map.get(head);
}

```

假设需要空间复杂度O(1)，则每次复制以后放原结点后，不设置rand，每次都是取一组，每次设置对应的rand，最后把分离出新老结点。

```java
public static Node copyListWithRand2(Node node){
    if(head == null){
        return null;
    }
    Node cur = head;
    Node next = null;
    while (cur != null){
        next = cur.next;
        cur.next = new Node(cur.value); //复制结点
        cur.next.next = next; 。//重新链接
        cur = next;
    }
    cur = head;
    Node curCopy = null;
    while(cur != null){
        next = cur.next.next; //一对对遍历
        curCopy = cur.next;
        curCopy.rand = cur.rand != null ? cur.rand.next : null;
        cur = next;
    }
    Node res = head.next;
    cur = head;
    while(cur != null){
        next = cur.next.next; //一对对遍历
        curCopy = cur.next;
        cur.next = next;
        curCopy.next = next != null ? next.next :null;
        cur = next;
	}
    return res;
}
```

4、两个单链表相交的一系列问题。给定两个可能有环也可能无环的单链表，头节点head1和head2。请实现一个函数，如果两个链表相交，请返回相交的第一个节点。如果不相交，返回null
如果两个链表长度之和为N，时间复杂度请达到O(N)，额外空间复杂度请达到O(1)。相交指的是共用结点的。



判断链表有无环，可以使用哈希表，每次遍历后检测是否在集合当中，假如不在则加入集合，在的话

则为第一个结点。假如一个链表有环，则一定出不来，每个结点只有一个next指针。



当要求空间复杂度的时候，使用快慢指针，当存在环的时候，快慢指针会相遇，而且两个指针的转的圈数一定不会超过两圈。当相遇后，快指针回到开头，慢指针不变，然后两个指针每次都走一步，一定环的第一个节点。



```java
public static Node getLoopNode(Node head){
    if(head == null || head.next == null || head.next.next == null) {
        return null;
    }
	Node n1 = head.next; // n1 -> slow
	Node n2 = head.next.next; // n2 -> fast
    while (n1 != n2) {
        if (n2.next == null || n2.next.next == null){
    		return null;
        }
		n2 = n2.next.next;
        n1 = n1.next;
	}
	n2 = head; //n2 -> walk again from head
    while (n1 != n2) {
		n1 = n1.next;
    	n2 = n2.next;
    }
    return n1;
}
```

当两个单链表都没有环，则要么不相交，要么后半部分是公共子部分。分别遍历两个链表，得到两个的链表length和end，判断end是否是一个结点，如果是一个，则是最后一个公共结点。长链表先走到长链表和短链表的的长度差，然后共同遍历，即可找到对应的第一个相交的第一个节点。

```java
public static Node noLoop(Node head1, Node head2){
    if(head1 == null || head2 == null){
        return null;
    }
    Node cur1 = head1;
    Node cur2 = head2;
    int n = 0;
    while(cur1.next != null){ //到最后一个结点
        n++;
        cur1 = cur1.next;
    }
    while(cur2.next != null){
        n--;
        cur2 = cur1.next;
    }
    if(cur1 != cur2){
        return null;
    }
    cur1 = n > 0 ? head1 : head2; //谁长，谁的头为cur1
    cur2 = cur1 == head1 ? head2 : head1; //谁短，谁的头变成cur2
    n = Math.obs(n);
    while(n != 0){
        n--;
        cur1 = cur1.next;
    }
    while(cur1 != cur2){
        cur1 = cur1.next;
        cur2 = cur2.next
    }
    return cur1;
}
```

当其中一个为空另一个不为空，这两个链表是不可能相交。



两个链表都有环时有三个情况：1、独立的。2、共用环入环结点是同一个。3、共用环入环结点不是同一个。



情况一：独立的。则loop1 != loop2

情况二：共用环入环结点是同一个。则使用无环结点相交问题，但是loop1和loop2是最后一个结点

情况三：loop1继续转，当转回自己路径中遇到loop2则返回loop2/loop1。



```java
public static Node bothLoop(Node head1, Node head2, Node loop1, Node loop2){
    Node cur1 = null;
    Node cur1 = null;
    if(loop1 == loop2){
        cur1 = head1;
        cur2 = head2;
        int n = 0;
        while(cur1.next != null){ //到最后一个结点
            n++;
            cur1 = cur1.next;
        }
        while(cur2.next != null){
            n--;
            cur2 = cur1.next;
        }
        if(cur1 != cur2){
            return null;
        }
        cur1 = n > 0 ? head1 : head2; //谁长，谁的头为cur1
        cur2 = cur1 == head1 ? head2 : head1; //谁短，谁的头变成cur2
        n = Math.obs(n);
        while(n != 0){
            n--;
            cur1 = cur1.next;
        }
        while(cur1 != cur2){
            cur1 = cur1.next;
            cur2 = cur2.next
        }
        return cur1;
    }else{
        cur1 = loop1.next;
        while(cur1 != loop1){
            if(cur1 != loop2){
                return loop1;
            }
            cur1 = cur1.next;
        }
        return null;
    }
}
```

```java
public static Node getIntersectNode(Node head1，Node head2){
	if (head1 == null || head2 == null) {
		return null;
	}
	Node loop1 = getLoopNode(head1);
    Node loop2 = getLoopNode(head2);
	if (loop1 == nu11 && loop2 == nul1) {
		return noLoop(head1,head2);
	}
	if (loop1 != null && loop2 != null) {
        return bothLoop(head1, head2, loop1, loop2);
    }
	return null;
}
```

# 二叉树

## 基础结构和递归化

链式结构下的二叉树一般如下定义、遍历。递归方法可以每次访问每个结点三次，在三次分别可以加工出三种遍历，即熟悉的先序、中序、后序遍历。

```java
class Node<V>{
    V value;
    Node left;
    Node right;
}
```

```java
public static void f(Node head){
    if(head == null){
        return;
    }
    //前序
    f(head.left);
    //中序
    f(head.right);
    //后续
}
```

任何递归都能改成非递归。



## 非递归化

### 先序遍历

1、把头节点放入栈。

2、在栈中弹出一个结点，记为car。

3、打印car。

4、把其右孩子压栈、再把左压栈（假如有）。

周而复始，直到栈空。

```java
public static void preOrderUnRecur(Node head){
    if(head != null){
        Stack<Node> stack = new Stack<Node>();
        stack.add(head);
        while(!stack.isEmpty()){
            head = stack.pop();
            System.out.print(head.value+" ");
            if(head.right != null){
                stack.push(head.right);
            }
            if(head.left != null){
                stack.push(head.left);
            }
        }
    }
    System.out.printIn();
}
```

### 后序遍历

先制作头右左顺序栈以打印，此时需要设置两个栈。

1、把头节点放入栈1。

2、在栈1中弹出一个结点，记为car。

3、把car放入栈2.

4、把其左孩子压栈、再把右压栈（假如有）。

5、栈2出栈，打印

周而复始，直到栈2空。



```java
public static void posOrderUnRecur(Node head){
    if(head != null){
        Stack<Node> stack1 = new Stack<Node>();
        Stack<Node> stack2 = new Stack<Node>();
        stack1.add(head);
        while(!stack1.isEmpty()){
            head = stack1.pop();
            stack2.push(head);
  			if(head.left != null){
                stack.push(head.left);
            }
            if(head.right != null){
                stack.push(head.right);
            }
        }
        while(!stack2.isEmpty()){
            System.out.print(stack2.pop().value+" ");
        }
    }
    System.out.printIn();
}
```

### 中序遍历

1、每棵把左边界全部压栈。

2、出栈时，打印

3、对出栈结点的右树重复。

```java
public static void inOrderUnRecur(Node head){
    if(head != null){
        Stack<Node> stack = new Stack<Node>();
        while(!stack.isEmpty() || head != null){
  			if(head != null){ //不停往左边界进栈
                stack.push(head);
                head = head.left;
            }else{
                head = stack.pop();
                System.out.print(head.value+" ");
                head = head.right;
            }
        }
    }
    System.out.printIn();
}
```

整个二叉树可以被整个左边界进行划分，我们以头左进行栈，出来就是左头。右树上再先左后头，左头**右**（**左**头右），实际进行的全部都为左头右。因此可以完成中序遍历。



## 如何打印一颗二叉树

这里给出一个快速打印函数

```java
public static void printInOrder(Node head, int height, String to, int len) {
		if (head == null) {
			return;
		}
		printInOrder(head.right, height + 1, "v", len); // 递归遍历右子树
		String val = to + head.value + to; // 处理并打印根节点
		int lenM = val.length();
		int lenL = (len - lenM) / 2;
		int lenR = len - lenM - lenL;
		val = getSpace(lenL) + val + getSpace(lenR);
		System.out.println(getSpace(height * len) + val);
		printInOrder(head.left, height + 1, "^", len); // 递归遍历左子树
	}
```

## 二叉树的宽度优先遍历

简单使用队列既可。

```java
public static void w(Node head){
    if(head == null){
        return;
    }
    Queue<Node> queue = new LinkedList<>();
    queue.add(head);
    while(!queue.isEmpty()){
        Node cur = queue.poll();
        System.out.println(cur.value);
        if(cur.left != null){
            queue.add(cur.left);
        }
        if(cur.right != null){
            queue.add(cur.right);
        }
    }
}
```

求一棵的树的最大宽度，需要记录每一层的层数，即使用哈希表。

```java
public static int w(Node head){
    if(head == null){
        return;
    }
    Queue<Node> queue = new LinkedList<>();
    HashMap<Node, Integer> levelMap = new HashMap<>();
    levelMap.put(head, 1);
    int curLevel = 1;
    int curLevelNodes = 0;
    int max = Integer.MIN_VALUE;
    queue.add(head);
    while(!queue.isEmpty()){
        Node cur = queue.poll();
        int curLevelNodes = levelMap.get(cur);
        if(curLevelNodes == curLevel){
            curLevelNodes++; //还在所统计层
        }else{
            max = Math.max(max,curLevelNodes);
            curLevel++;
            curLevelNodes = 0;
        }
        if(cur.left != null){
            levelMap.put(cur.left,curLevelNodes+1);//登记孩子结点所在层数
            queue.add(cur.left);
        }
        if(cur.right != null){
             levelMap.put(cur.right,curLevelNodes+1);
            queue.add(cur.right);
        }
    }
    return max;
}
```

不使用哈希表的时候，需要设置三个变量：Nodecurend、Nextend、curlevelNodes、max

```java
public static int w(Node head){
    if(head == null){
        return;
    }
    Queue<Node> queue = new LinkedList<>();
    Node Nodecurend = head; //头结点
    Node Nextend = null;
    int curLevelNodes = 0;
    int max = Integer.MIN_VALUE;
    queue.add(head);
    while(!queue.isEmpty()){
        Node cur = queue.poll();
        if(cur.left != null){
            queue.add(cur.left);
            Nextend = cur.left;
        }
        if(cur.right != null){
            queue.add(cur.right);
            Nextend = cur.right;
        }
        if(cur == Nodecurend){
            max = Math.max(max,curLevelNodes);
            curLevelNodes = 0;
            Nodecurend = Nextend;
        }else{
            curLevelNodes++;
            continue;
        }
    }
    return max;
}
```

## 二叉树的相关概念及其判断

### 判断搜索二叉树

左子树的结点比根节点小，右子树都比他大。故中序遍历下得到的一定是升序的。

```java
public static boolean isBST2(Node head){ //递归
    List<Node> inOrderList = new ArrayList<>();
    isBSTprocess(head, inOrderList);
    //...检查是否升序
}

public static boolean isBSTprocess(Node head, List<Node> inOrderList){
    if(head == null){
        return ture;
    }
    isBSTprocess(head.left, inOrderList)
	inOrderList.add(head);
   	isBSTprocess(head.right, inOrderList)
}
```

```java
public static int preValue = Integer.MIN_VALUE;

public static boolean isBST1(Node head){ //动态检查
    if(head == null){
        return ture;
    }
    boolean isLeftBST = isBST(Node head);
    if(!isLeftBST){
        return false;
    }
    if(head.value <= preValue){
        return false;
    }else{
        preValue = head.value;
    }
   	return isBST(head.right);
}
```

```java
public static boolean isBST3(Node head){ //非递归
    if(head != null){
        int preValue = Integer.MIN_VALUE;
        Stack<Node> stack = new Stack<Node>();
        while(!stack.isEmpty() || head != null){
  			if(head != null){ //不停往左边界进栈
                stack.push(head);
                head = head.left;
            }else{
                head = stack.pop();
                if(head.value <= preValue){
       				 return false;
                }else{
                    preValue = head.value;
                }
                head = head.right;
            }
        }
    }
    return true;
}
```

### 判断完全二叉树

按宽度遍历二叉树

- 遇到的任一结点假如只有右孩子没有左孩子则一定不是完全二叉树。
- 在上一条条件下遇到了第一个左右孩子不全的时候，后续均为叶子结点，否则不是完全二叉树。

```java
public static boolean isCBT(Node head){
    if(head == null){
        return true;
    }
    LinkedList<Node> queue = new LinedList<>();
    boolean leaf = false;
    Node l = null;
    Node r = null;
    queue.add(head);
    while(!queue.isEmpty()){
        head = queue.poll();
        l = head.left;
        r = head.right;
        if( //遇到不双全的结点，又发现当前结点有孩子
        	(leaf && (l != null || r != null)) 
            ||
            (l == null && r != null)
        ){
            return false;
        }
        if(l != null){
            queue.add(l);
        }
        if(r != null){
            queue.add(r);
        }
        if(l == null || r == null){
            leaf = true;
        }
    }
    return true;
}
```

### 判断满二叉树

统计最大深度h、以及结点个数N满足N=2<sup>h</sup>-1。



### 判断平衡二叉树（二叉树套路）

首先介绍套路求解法。

想知道到底是不是平衡二叉树，需要左/右树给出：1、是否是平衡二叉树。2、高度。

```java
public static boolean isBalanced(Node head){
    return process(head).isBlanced;
}

public static class ReturnType{
        public boolean isBlanced;
        public int height;
        public ReturnType(boolean isB, int hei){
             isBlanced = isB;
             height = hei;
        }
 }
public static ReturnType process(Node x){
    if(x == null){ //base
        return new ReturnType(true, 0);
    }
    
    ReturnType leftData = process(x.left);
    ReturnType rightData = process(x.right);
    
    int height = Math.max(leftData.height, rightData.height) + 1;
    boolean isBalanced = leftData.isBalanced && rightData.isBlanced
        				 && Math.max(leftData.height - rightData.height) < 2;
    return new ReturnType(isBalanced, height);
}
```

想知道到底是不是搜索二叉树，需要左/右树给出：1、是否是搜索二叉树。2、左树最大值小于根结点，右树上的最小值大于根结点，即左树最大值、右数最小值。但递归要求是一样的，即全部返回左数最大值、右数最小值。

```java
public static class ReturnType{
        public boolean isBST;
    	public int min;
        public int max;
        public ReturnType(boolean is, int mi, int ma){
            isBST = is;
            min = mi;
            max = ma;
        }
 }
public static ReturnType process(Node x){
    if(x == null){ //base
        return null;
    }
    ReturnType leftData = process(x.left);
    ReturnType rightData = process(x.right); 
    int min = x.value;
    int max = x.value;
    if(leftData != null){
        min =  Math.min(min, leftData.min);
        max =  Math.max(max, leftData.max);
    }
    if(rightData != null){
        min =  Math.min(min, rightData.min);
        max =  Math.max(max, rightData.max);
    }
    boolean isBST = true;
    if(leftData != null && (!leftData.isBST || leftData.max >= x.value){
        isBST = false;
    }
    if(rightData != null && (!rightData.isBST || x.value >= rightData.min){
        isBST = false;
    }
    return new ReturnData(isBST, min, max);
}
```

树形DP的问题(左树要信息、右树要信息可以解决的)可以套路全部解决：1、信息问题。2、递归结构。



满二叉树即统计最大深度h、以及结点个数N满足N=2<sup>h</sup>-1。

```java
public static Info  process(Node head){
    if(head == null){
        return new Info(0, 0);
    }
    Info leftData = process(x.left);
    Info rightData = process(x.right);
    
    int height = Math.max(leftData.height, rightData.height)+1;
    int nodes = leftData.nodes +rightData.nodes+1;
    
    
    return new Info(height, nodes)
    
}

public static class Info{
    public int height;
    public int nodes;
    public Info(int h, int n){
        height = h;
        nodes = n;
    }
}

public static boolean isF(Node head){
    if(head == null){
        return true;
    }
    Info data = process(head);
    return data.nodes == (1 << data.height - 1);
}
```

## 二叉树的最低公共祖先

```java
public static Node lca(Node head, Node o1, Node o2){
    HashMap<Node, Node> fatherMap = new HashMap<>();
    fatherMap.put(head, head);
    process(head, fatherMap);
    
    HashSet<Node> set01 = new HashSet<>();
    
    Node cur = o1;
    while(cur != fatherMap.get(cur)){ //只有头结点等于自己的父
        set1.add(o1);
        cur = fatherMap.get(cur);
    }
    set1.add(head);
    
    cur = o2;
    while(cur != fatherMap.get(cur)){ //只有头结点等于自己的父
        //每次去set里面找在不在
        cur = fatherMap.get(cur);
    }
}

public static void process(Node head, HashMap<Node, Node> fatherMap){
    if(head == null){
        return;
    }
    fatherMap.put(head.left, head);
    fatherMap.put(head.right, head);
    process(head.left, fatherMap);
    process(head.right, fatherMap);
    
}
```

给定两个二叉树的最低公共祖先在改进后：

1、o1是o2的公共祖先或者恰好相反。

2、o1和o2不互为公共祖先，需要汇聚。

```java
//改进
public static Node LowestAncestor(Node head, Node o1, Node o2){
    
    if(head == null || head == o1 || head == o2){
        return head;
    }
    
    Node left = LowestAncestor(head.left, o1, o2);
    Node right = LowestAncestor(head.right, o1, o2);
    //只可能返回o1,o2,null，当左右非空的时候，即情况2返回自己。
    if(left != null && right != null){ 
        return head;
    }
    //左右两棵树，并不都有返回值
    return left != null ? left : right;
}
```

## 找二叉树的后续结点

根据分析结点x有下列情况：

1、x有右树的时候，则后续结点为右树的最左结点

2、x无右树的时候，则判断是不是其父亲结点的左孩子

```java
public static Node getLeftMost(Node node){
    if(node == null){
        return node;
    }
    while(node.left != null){
        node = node.left;
    }
    return node;
}

public static Node getSuccessorNode(Node node){
    if(node == null){
        return node;
    }
    if(node.right != null){
        return getLeftMost(node.right);
    }else{ //无右子树
        Node parent = node.parent;
        while(parent != null && parent.left != node){ //当前结点是其父亲的右孩子
            node = parent;
            parent = node.parent;
        }
        return parent; //返回parent或者null（此时，node是整颗树的最右的结点）
    }
}
```

## 二叉树的序列化和反序列化

序列化和反序列化就是内存中的一棵树如何变成字符串形式，又如何从字符串形式变为内存里的树。



对应二叉树的遍历，这里介绍先序遍历序列化的过程：先序遍历，遇到值存值，遇到空值为#，下划线表示结束。



反序列化，把字符串按_进行分割形成一个数组，然后按照先序遍历进行队列消费建树。



```java
public static string serialByPre(Node node){
    if(head == null){
        return "#_";
    }
    String res = head.value + "_";
    res + = serialByPre(head.right);
    return res;   
}

public static Node reconByerialByPreString(String preStr){
    String[] values = preStr.split("_");
    Queue<String> queue = new LinkedList<String>();
    for(int i = 0; i != values.length; i++){
        queue.add(value[i]);
    }
    return reconPreOrder(queue);
}

public static Node reconPreOrder(Queue<String> queue){
    String value = queue.poll();
    if(value.equals("#")){
        return null;
    }
    Node head = new Node(Integer.valueOf(value));
    head.left = reconPreOrder(queue);
    head.right = reconPreOrder(queue);
    return head;
}
```

剩余的其他方式的序列都一致。

## 折纸二叉树

当一张纸进行反复折，打印出折横。

```java
public static void printAllFolds(int N){
    printProcess(1, N, true);
}
//i是结点层数，N为一共的层数，down == true 凹 down == false 凸
public static void printProcess(int i, int N, boolean down){
    if(i > N){
        return;
    }
    printProcess(i + 1, N, true);
    System.out.printIn(down ? "凹"："凸")；
    printProcess(i + 1, N, false);
}
```

# 图

## 图的存储方式

图的存储方式主要有邻接表、邻接矩阵两个方式。



建议自己写一个图的写的模板，但面对题目的时候，转化为自己所使用的结构，即设定一个接口。

```java
public class Graph{
    public HashMap<Integer, Node> nodes; //点的编号与点
    public HashSet<Edge> edge; //边

	public Graph(){
        nodes = new HashMap<>();
        edges = new HashSet<>();
    }
}

public class Node{
    public int value;
    public int in; //入度
    public int out; //出度
    public ArrayList<Node> nexts;//当前点发散的边到其他的点
 	public ArrayList<Edge> edges;//当前点发散到其他点的边
    
    public Node(int value){
        this.value = value;
        in = 0;
        out = 0;
        nexts = new ArrayList<>();
        edges = new ArrayList<>();
    }
    
}
public class Edge {
    public int weight;
    public Node from;
    public Node to;
    
    public Edge(int weight, Node from, Node to){
        this.weight = weight;
        this.from = from;
        this.to = to;
    }
}
```

根据用户需求所给的转换为以上模板的数据结构，不需要某些数据项的时候，不必写那个数据项即可。

## 宽度优先遍历

1、利用队列实现。
2、从源节点开始依次按照宽度进队列，然后弹出。
3、每弹出一个点，把该节点所有没有进过队列的邻接点放入队列4，直到队列变空。

```java
public static void bfs(Node node){
    if(node == null){
        return;
    }
    Queue<Node> queue = new LinkedList<>();
    HashSet<Node> set = new HashSet<>();//去重机制
    queue.add(node);
    set.add(node);
    while(!queue.isEmpty()){
        Node cur = queue.poll();
        System.out.printIn(cur.value);
        for(Node next : cur.nexts){
        	if(!set.contains(next)){
                set.add(next);
                queue.add(next);
            }	
        }
    }
}
```

当N不大的时候，可以使用数组结构替代哈希表，速度更快。

## 深度优先遍历

1、利用栈实现。
2、从源节点开始把节点按照深度放入栈，然后弹出。
3、每弹出一个点，把该节点下一个没有进过栈的邻接点放入栈4，直到栈变空。

```java
public static void dfs(Node node){
    if(node == null){
        return;
    }
    Stack<Node> stack = new stack<>(); //栈存储深度的路径
    HashSet<Node> set = new HashSet<>();//去重机制
    stack.add(node);
    set.add(node);
    System.out.printIn(cur.value);
    while(!queue.isEmpty()){
        Node cur = stack.pop();
        for(Node next : cur.nexts){
        	if(!set.contains(next)){
                stack.push(cur); //压回原栈
                stack.push(next); //再压回邻居
            	set.add(next);
            	System.out.printIn(next.value); //处理邻居
                break;
            }	
        }
    }
}
```

## 拓扑排序算法

常用在工程组织的时候，必然是一个无环的有向图，比如在依赖包不能相互依赖。

```java
public static List<Node> sortedTopology(Graph graph){
    //key：某一个node
    //value: 剩余的入度
    HashMap<Node, Integer> inMap = new HashMap<>();
    Queue<Node> zeroInQueue = new LinkedList<>();
    //入度为0的点才能进入队列,找每一个点存表找每一个入度为0的点
    for(Node node : graph.nodes.values()){ // 遍历哈希表的value值函数
        inMap.put(node, node.in); 
        if(node.in == 0){
            zeroInQueue.add(node);
        }
    }
    List<Node> result = new ArrayList<>();
    while(!zeroInQueue.isEmpty()){
        Node cur = zeroInQueue.poll();
        result.add(cur);
        for(Node.next : cur.nexts){
            inMap.put(next, inMap.get(next) - 1); //擦去一个减少一个
            if(inMap.get(next) == 0){
                zeroInQueue.add(next); //某个入度没了加入result
            }
         }
    }
    return result;
}
```

## 最小生成树

### Krusal算法

无向图上的生成最小生成树算法，即保证所有结点都是连通的，且要求每一条边的权值和是最小的。



每次先抓最小的边，判断有无形成环。假设某个结点为单独的集合，当加入的时候，把两个包含的集合合成一个大集合。

```java
public static class Mysets{
    public HashMap<Node, List<Node>> setMap; //当前点和该点所在集合
    
    public MySet(List<Node> nodes){ //把所有结点全部分配集合
        for(Node cur: nodes){
            List<Node> set = new ArrayList<Node>();
            set.add(cur);
            setMap.put(cur, set);
        }
    }
    //判断两个结点是否是同一个集合
    public boolean isSameSet(Node from, Node to){ 
        List<Node> fromSet = setMap.get(from);
        List<Node> toSet = setMap.get(to);
        return fromSet == toSet;
    }
    //把两个集合合并
    public void union(Node from, Node to){
        List<Node> fromSet = setMap.get(from);
        List<Node> toSet = setMap.get(to);
        //把to集合里面所有结点放到from集合中
        for(Node toNode :toSet){ 
            fromSet.add(toNode);
            setMap.put(toNode, fromSet);
        }
    }
}
```

并查集的使用实现该算法。

```java
public static Set<Edge> kruskalMST(Graph graph){
    UnionFind unionFind = new UnionFind();//并查集
    unionFind.makeSets(graph.nodes.values());
    PriorityQueue<Edge> priorityQueue = new PriorityQueue<>(new EdgeComparator());//搞一个堆，按边的权值从小到大弹出
    for(Edge edge : graph.edges){
        priorityQueue.add(edge);
    }
    Set<Edge> result = new HashSet<>(); //每一条边
    while(!priorityQueue.isEmpty()){
        Edge edge = priorityQueue.poll();
        if(!unionFind.isSameSet(edge.from, edge.to)){
            result.add(edge); //不是一个集合要这条边
            unionFind.union(edge.from, edge.to);
        }
    }
    return result;
}
```

### Prim算法

无向图上的生成最小生成树算法。虽然边可能会重复进队列，即便被重新处理，但是判断的机制下，这是不影响的。

```java
public static Set<Edge> primMST(Graph graph){
    PriorityQueue<Edge> priorityQueue = new PriorityQueue<>(new EdgeComparator());//搞一个堆，按边的权值从小到大弹出
    HashSet<Node> set = new HashSet<>(); //不在set就是在新的点
    Set<Edge> result = new HashSet<>(); //依次挑选的边在result
    for(Node node : graph.nodes.values()){ //随便挑一个点，避免是非连通图，假如是连通的，可省略
        //Node是开始点
        if(!set.contains(node)){
            set.add(node);
            for(Edge edge : node.edges){ //把这个点所有边加入优先级队列
                priorityQueue.add(edge);
            }
        	while(!priorityQueue.isEmpty()){
                Edge edge = priorityQueue.poll(); //优先级队列拿一个边
                Node toNode = edge.to; 
                //看看这个点是不是新的点，如果是
                if(!set.contains(toNode)){ 
                    set.add(toNode);
                    result.add(edge);
                    //再把该点发散的边放到优先级队列中
                    for(Edge nextEdge : toNode.egdes){ 
                        priorityQueue.add(nextEdge);
                    }
                }
            }
        }
    }
}
```

## 最短路径

### Dijkstra算法

给出出发点，找到它到其他结点的最短路径，且要求权值非负。

```java
public static HashMap<Node, Integer> dijkstra1(Node from) {
    //所有的距离都是指出发点到其他点的距离
	HashMap<Node, Integer> distanceMap = new HashMap<>();
	//key：从起始点出发到达key
	//value：从起始点出发到达key的最小距离
	//如果在表中，没有T的记录，含义是从from出发到T点的距离为正无穷
	distanceMap.put(from, 0);
	// 打过对号的点
	HashSet<Node> selectedNodes = new HashSet<>();
	//从未选择过的点(selectedNodes之外的)选择距离最小的点，selectedNodes是黑名单，不要从里面选
	Node minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);
	while (minNode != null) {
		//  原始点  ->  minNode(跳转点)   最小距离distance
		int distance = distanceMap.get(minNode);
		for (Edge edge : minNode.edges) {
			Node toNode = edge.to; //找他的边连的结点
			if (!distanceMap.containsKey(toNode)) {
				distanceMap.put(toNode, distance + edge.weight);
			} else { // toNode之前的距离和现在加的距离比大小
				distanceMap.put(edge.to, Math.min(distanceMap.get(toNode), distance + edge.weight));
			}
		}
		selectedNodes.add(minNode);//锁
		minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);//找没锁的最小的
	}
	return distanceMap;
}

public static Node getMinDistanceAndUnselectedNode(HashMap<Node, Integer> distanceMap, HashSet<Node> touchedNodes) {
	Node minNode = null;
	int minDistance = Integer.MAX_VALUE;
	for (Entry<Node, Integer> entry : distanceMap.entrySet()) {
		Node node = entry.getKey();
		int distance = entry.getValue();
		if (!touchedNodes.contains(node) && distance < minDistance) {
			minNode = node;
			minDistance = distance;
		}
	}
	return minNode;
}
```

可以利用堆来进行实现，不必遍历，但是系统堆是不允许随意改值，需要自定义堆。

```java
public static class NodeRecord {
	public Node node;
	public int distance;

	public NodeRecord(Node node, int distance) {
		this.node = node;
		this.distance = distance;
	}
}

public static class NodeHeap {
	private Node[] nodes; // 实际的堆结构
	// key 某一个node， value 上面堆中的位置
	//如果进来之后弹出了，我们记录下标(value)为-1
	private HashMap<Node, Integer> heapIndexMap;
	// key 某一个节点， value 从源节点出发到该节点的目前最小距离
	private HashMap<Node, Integer> distanceMap;
	private int size; // 堆上有多少个点

	public NodeHeap(int size) {
		nodes = new Node[size];
		heapIndexMap = new HashMap<>();
		distanceMap = new HashMap<>();
		size = 0;
	}

	public boolean isEmpty() {
		return size == 0;
	}

	// 有一个点叫node，现在发现了一个从源节点出发到达node的距离为distance
	// 判断要不要更新，如果需要的话，就更新
	public void addOrUpdateOrIgnore(Node node, int distance) {
		if (inHeap(node)) {
			distanceMap.put(node, Math.min(distanceMap.get(node), distance));
			insertHeapify(node, heapIndexMap.get(node));
		}
		if (!isEntered(node)) {
			nodes[size] = node;
			heapIndexMap.put(node, size);
			distanceMap.put(node, distance);
			insertHeapify(node, size++);
		}
	}

	public NodeRecord pop() {
		NodeRecord nodeRecord = new NodeRecord(nodes[0], distanceMap.get(nodes[0]));
		swap(0, size - 1);
		heapIndexMap.put(nodes[size - 1], -1);
		distanceMap.remove(nodes[size - 1]);
		// free C++同学还要把原本堆顶节点析构，对java同学不必
		nodes[size - 1] = null;
		heapify(0, --size);
		return nodeRecord;
	}

	private void insertHeapify(Node node, int index) {
		while (distanceMap.get(nodes[index]) < distanceMap.get(nodes[(index - 1) / 2])) {
			swap(index, (index - 1) / 2);
			index = (index - 1) / 2;
		}
	}

	private void heapify(int index, int size) {
		int left = index * 2 + 1;
		while (left < size) {
			int smallest = left + 1 < size && distanceMap.get(nodes[left + 1]) < distanceMap.get(nodes[left])
					? left + 1
					: left;
			smallest = distanceMap.get(nodes[smallest]) < distanceMap.get(nodes[index]) ? smallest : index;
			if (smallest == index) {
				break;
			}
			swap(smallest, index);
			index = smallest;
			left = index * 2 + 1;
		}
	}

	//返回点有没有进来过
	private boolean isEntered(Node node) {
		return heapIndexMap.containsKey(node);
	}

	//判断是否在堆里
	private boolean inHeap(Node node) {
		return isEntered(node) && heapIndexMap.get(node) != -1;
	}

	private void swap(int index1, int index2) {
		heapIndexMap.put(nodes[index1], index2);
		heapIndexMap.put(nodes[index2], index1);
		Node tmp = nodes[index1];
		nodes[index1] = nodes[index2];
		nodes[index2] = tmp;
	}
}

// 改进后的dijkstra算法
// 从head出发，所有head能到达的节点，生成到达每个节点的最小路径记录并返回
public static HashMap<Node, Integer> dijkstra2(Node head, int size) {
	NodeHeap nodeHeap = new NodeHeap(size);
	nodeHeap.addOrUpdateOrIgnore(head, 0);
	HashMap<Node, Integer> result = new HashMap<>();
	while (!nodeHeap.isEmpty()) {
		NodeRecord record = nodeHeap.pop();
		Node cur = record.node;
		int distance = record.distance;
		for (Edge edge : cur.edges) {
	addOrUpdateOrIgnore(edge.to, edge.weight + distance);
		}
		result.put(cur, distance);
	}
		return result;
}
```

# 前缀树

## 概念

假设`vector<string>`存储了四个`string`对象，建立一棵树，遍历每个`string`对象的每个字符，有通往该字符没有路，则添加这条路，否则按走这条路。每个`string`从头结点开始。



为了更加便于复用，点的定义如下。

```c
public static class TrieNode{
    public int pass;//建立前缀树的时候，该点通过次数
    public int end;//该结点是否是结尾结点，如果是则是多少个字符串的结尾结点
    public TrieNode[] nexts;//字符超过26个，换成HashMap<char,TrieNode> next;
    
    public TrieNode(){
        pass = 0;
        end = 0;
        //next[0]==null 没有走向`a`的路
        //next[0]!=null 有走向`a`的路
        next = new TrieNode[26];
    }
}
```

建立号前缀树后：

- 查某个`string`对象加入树/加入了几次：按建树逻辑查询，如果`end`不为0则代表加入过，其值代表加入了几次。时间代价是字符数量。（哈希表可以完成）
- 可以常数级别找到以`string`对象为前缀的`string`对象：按建树逻辑查询，查前缀`string`对象的`p`值。时间代价是字符数量。（前缀树特有）

## 建立前缀树

```java
public void insert(String word){ //假如空串，则根结点root的pass和end都加一
    if(word==null){
        return;
    }
    char[] chs = word.toCharArray();
    TrieNode node = root;
    node.pass++;
    int index = 0;
    for(int i = 0; i<chs.length; i++){
        index = chs[i] -'a';//减去对应的ASCLL值
        if(node.nexts[index]==null){
            node.nexts[index]== new TrieNode();
        }
        node = node.nexts[index];
        node.next++;
    }
    node.end++;
}
```

## 查询加入次数

```java
public void search(String word){ //假如空串，则根结点root的pass和end都加一
    if(word==null){
        return;
    }
    char[] chs = word.toCharArray();
    TrieNode node = root;
    node.pass++;
    int index = 0;
    for(int i = 0; i<chs.length; i++){
        index = chs[i] -'a';//减去对应的ASCLL值
        if(node.nexts[index]==null){
            return 0;
        }
        node = node.nexts[index];
    }
    return node.end;
}
```

## 查询前缀串

```java
public void prefixNumber(String word){ //假如空串，则根结点root的pass和end都加一
    if(word==null){
        return;
    }
    char[] chs = word.toCharArray();
    TrieNode node = root;
    node.pass++;
    int index = 0;
    for(int i = 0; i<chs.length; i++){
        index = chs[i] -'a';//减去对应的ASCLL值
        if(node.nexts[index]==null){
            return 0;
        }
        node = node.nexts[index];
    }
    return node.pass;
}
```

## 删除前缀串

```java
public void delete(String word){ 
    if(search(word)!=0){
        char[] chs = word.toCharArray();
        TrieNode node = root;
        node.pass--;
        int index = 0;
        for(int i = 0; i<chs.length; i++){
            index = chs[i] -'a';//减去对应的ASCLL值
            if(--node.nexts[index].pass==0){//结点没用了
                //只有Java这样写
                node.nexts[index] = null;
                return;
                //C++要遍历到底，然后沿途析构掉，需要自己进行内存管理，或者使用智能指针，或者记录第一个需要进行析构的父节点，把需要析构的子节点全部放set里面，把父节点置空，最后一次性析构set集合
            }
            node = node.nexts[index];
        }
        node.end--;
    }

}
```

# 贪心算法

## 概念

在某个一个标准，优先考虑最满足标准的样本，最后考虑最不满足标准的样本。做出局部最优解



解题套路：

1. 实现一个不依靠贪心策略的解法x，可以用最暴力的尝试
2. 脑补贪心策略
3. 用解法x和对数器i，去验证每一个贪心策略，用实验那个贪心策略正确
